signatures
colnames(matches)
### Remove small groups
groups<-groups[sapply(groups,length)>=minsize]
### Treat single "signature"
if (is.null(nrow(signatures))){
signatures <- matrix(signatures, length(signatures), 1,
dimnames=list(names(signatures), "sample1"))
}
signatures
### Generate dummy signature weights
if(is.null(sweights)){
sweights<-matrix(1,nrow=nrow(signatures),ncol=ncol(signatures))
dimnames(sweights)<-dimnames(signatures)
}
if(!identical(dim(signatures), dim(sweights))){
stop("Signatures and Signature weights must be
matrices of identical size")
}
### Generate dummy group weights
if(is.null(gweights)){
gweights<-relist(rep(1,sum(sapply(groups,length))),skeleton=groups)
}
gweights=NULL
### Generate dummy group weights
if(is.null(gweights)){
gweights<-relist(rep(1,sum(sapply(groups,length))),skeleton=groups)
}
### Apply weights to group belonging
wgroups<-gweights
for(i in 1:length(wgroups)){
names(wgroups[[i]])<-groups[[i]]
}
### Rank-transform columns
ranks<-apply(signatures,2,rank,na.last="keep")
### Assign a 0 to signature weights where the signature was NA
sweights[is.na(ranks)]<-0
### 0-1 bound ranks
boundranks<-t(t(ranks)/(colSums(!is.na(signatures))+1))
# Treat bound ranks as quantiles in a gaussian distribution (0=-Inf, 1=+Inf)
gaussian <- qnorm(boundranks)
### Deal with NAs
gaussian[is.na(gaussian)]<-0
### Apply signature weights to the normalized distribution
gaussian<-gaussian*sweights
### Next, we see how each of the groups are behaving in these normalized
### signatures
### Create a boolean matrix with ngroup columns and signaturelength rows,
### indicating the matches
matches <- sapply(wgroups, function(group, allElements) {
hereMatches<-as.integer(allElements%in%names(group))
names(hereMatches)<-allElements
# Weigth by group belonging
weightedMatches<-hereMatches
weightedMatches[names(group)]<-weightedMatches[names(group)]*group
return(weightedMatches)
}, allElements=rownames(gaussian))
# And then transpose it
matches<-t(matches)
colnames(matches)<-rownames(signatures)
colnames(matches)<-colnames(signatures)
dim(signatures)
dim(matches)
rownames(matches)<-rownames(signatures)
rownames(matches)<-colnames(signatures)
# Number of matches per group
groupmatches <- rowSums(matches)
signatures1<-setNames(-sort(rnorm(26)),LETTERS)
signatures2<-setNames(rnorm(26),LETTERS)
signatures<-cbind(signatures1,signatures2)
groups<-list(set1=set1,set2=set2,set3=set3,set4=set4)
obj<-rea(signatures=reflist,groups=groups)
### Remove small groups
groups<-groups[sapply(groups,length)>=minsize]
### Treat single "signature"
if (is.null(nrow(signatures))){
signatures <- matrix(signatures, length(signatures), 1,
dimnames=list(names(signatures), "sample1"))
}
### Generate dummy signature weights
if(is.null(sweights)){
sweights<-matrix(1,nrow=nrow(signatures),ncol=ncol(signatures))
dimnames(sweights)<-dimnames(signatures)
}
if(!identical(dim(signatures), dim(sweights))){
stop("Signatures and Signature weights must be
matrices of identical size")
}
### Generate dummy group weights
if(is.null(gweights)){
gweights<-relist(rep(1,sum(sapply(groups,length))),skeleton=groups)
}
### Apply weights to group belonging
wgroups<-gweights
for(i in 1:length(wgroups)){
names(wgroups[[i]])<-groups[[i]]
}
sweights=NULL
gweights=NULL
### Remove small groups
groups<-groups[sapply(groups,length)>=minsize]
### Treat single "signature"
if (is.null(nrow(signatures))){
signatures <- matrix(signatures, length(signatures), 1,
dimnames=list(names(signatures), "sample1"))
}
### Generate dummy signature weights
if(is.null(sweights)){
sweights<-matrix(1,nrow=nrow(signatures),ncol=ncol(signatures))
dimnames(sweights)<-dimnames(signatures)
}
if(!identical(dim(signatures), dim(sweights))){
stop("Signatures and Signature weights must be
matrices of identical size")
}
### Generate dummy group weights
if(is.null(gweights)){
gweights<-relist(rep(1,sum(sapply(groups,length))),skeleton=groups)
}
### Apply weights to group belonging
wgroups<-gweights
for(i in 1:length(wgroups)){
names(wgroups[[i]])<-groups[[i]]
}
### Rank-transform columns
ranks<-apply(signatures,2,rank,na.last="keep")
### Assign a 0 to signature weights where the signature was NA
sweights[is.na(ranks)]<-0
### 0-1 bound ranks
boundranks<-t(t(ranks)/(colSums(!is.na(signatures))+1))
# Treat bound ranks as quantiles in a gaussian distribution (0=-Inf, 1=+Inf)
gaussian <- qnorm(boundranks)
### Deal with NAs
gaussian[is.na(gaussian)]<-0
### Apply signature weights to the normalized distribution
gaussian<-gaussian*sweights
### Next, we see how each of the groups are behaving in these normalized
### signatures
### Create a boolean matrix with ngroup columns and signaturelength rows,
### indicating the matches
matches <- sapply(wgroups, function(group, allElements) {
hereMatches<-as.integer(allElements%in%names(group))
names(hereMatches)<-allElements
# Weigth by group belonging
weightedMatches<-hereMatches
weightedMatches[names(group)]<-weightedMatches[names(group)]*group
return(weightedMatches)
}, allElements=rownames(gaussian))
# And then transpose it
matches<-t(matches)
matches
rownames(matches)<-colnames(signatures)
signatures<-setNames(-sort(rnorm(1000)),paste0("gene",1:1000))
set1<-paste0("gene",sample(1:200,50))
set2<-paste0("gene",sample(1:1000,50))
groups<-list(set1=set1,set2=set2)
obj<-rea(signatures=signatures,groups=groups)
### Remove small groups
groups<-groups[sapply(groups,length)>=minsize]
### Treat single "signature"
if (is.null(nrow(signatures))){
signatures <- matrix(signatures, length(signatures), 1,
dimnames=list(names(signatures), "sample1"))
}
### Generate dummy signature weights
if(is.null(sweights)){
sweights<-matrix(1,nrow=nrow(signatures),ncol=ncol(signatures))
dimnames(sweights)<-dimnames(signatures)
}
if(!identical(dim(signatures), dim(sweights))){
stop("Signatures and Signature weights must be
matrices of identical size")
}
### Generate dummy group weights
if(is.null(gweights)){
gweights<-relist(rep(1,sum(sapply(groups,length))),skeleton=groups)
}
### Apply weights to group belonging
wgroups<-gweights
for(i in 1:length(wgroups)){
names(wgroups[[i]])<-groups[[i]]
}
sweights=NULL
gweights=NULL
### Remove small groups
groups<-groups[sapply(groups,length)>=minsize]
### Treat single "signature"
if (is.null(nrow(signatures))){
signatures <- matrix(signatures, length(signatures), 1,
dimnames=list(names(signatures), "sample1"))
}
### Generate dummy signature weights
if(is.null(sweights)){
sweights<-matrix(1,nrow=nrow(signatures),ncol=ncol(signatures))
dimnames(sweights)<-dimnames(signatures)
}
if(!identical(dim(signatures), dim(sweights))){
stop("Signatures and Signature weights must be
matrices of identical size")
}
### Generate dummy group weights
if(is.null(gweights)){
gweights<-relist(rep(1,sum(sapply(groups,length))),skeleton=groups)
}
### Apply weights to group belonging
wgroups<-gweights
for(i in 1:length(wgroups)){
names(wgroups[[i]])<-groups[[i]]
}
### Rank-transform columns
ranks<-apply(signatures,2,rank,na.last="keep")
### Assign a 0 to signature weights where the signature was NA
sweights[is.na(ranks)]<-0
### 0-1 bound ranks
boundranks<-t(t(ranks)/(colSums(!is.na(signatures))+1))
# Treat bound ranks as quantiles in a gaussian distribution (0=-Inf, 1=+Inf)
gaussian <- qnorm(boundranks)
### Deal with NAs
gaussian[is.na(gaussian)]<-0
### Apply signature weights to the normalized distribution
gaussian<-gaussian*sweights
### Next, we see how each of the groups are behaving in these normalized
### signatures
### Create a boolean matrix with ngroup columns and signaturelength rows,
### indicating the matches
matches <- sapply(wgroups, function(group, allElements) {
hereMatches<-as.integer(allElements%in%names(group))
names(hereMatches)<-allElements
# Weigth by group belonging
weightedMatches<-hereMatches
weightedMatches[names(group)]<-weightedMatches[names(group)]*group
return(weightedMatches)
}, allElements=rownames(gaussian))
# And then transpose it
matches<-t(matches)
rownames(matches)<-colnames(signatures)
matches
signatures
matches
# Number of matches per group
groupmatches <- rowSums(matches)
# Relative part of the signature that matches
relativematches<-matches/groupmatches
# This trick will overweight massively small groups with all their
# components highly-ranked.
# Extreme case is with a group with one gene at the top
# The core linear algebra operation. The true magic of rea
enrichmentScore <- relativematches %*% gaussian
# Finally, every enrichment is square-rooted to respect the criterion
# of normality
normalizedEnrichmentScore<-enrichmentScore*sqrt(groupmatches)
document()
library(vulcan)
?rea
rea<-function(
signatures,
groups,
sweights=NULL,
gweights=NULL,
minsize=1
){
### Remove small groups
groups<-groups[sapply(groups,length)>=minsize]
### Treat single "signature"
if (is.null(nrow(signatures))){
signatures <- matrix(signatures, length(signatures), 1,
dimnames=list(names(signatures), "sample1"))
}
### Generate dummy signature weights
if(is.null(sweights)){
sweights<-matrix(1,nrow=nrow(signatures),ncol=ncol(signatures))
dimnames(sweights)<-dimnames(signatures)
}
if(!identical(dim(signatures), dim(sweights))){
stop("Signatures and Signature weights must be
matrices of identical size")
}
### Generate dummy group weights
if(is.null(gweights)){
gweights<-relist(rep(1,sum(sapply(groups,length))),skeleton=groups)
}
### Apply weights to group belonging
wgroups<-gweights
for(i in 1:length(wgroups)){
names(wgroups[[i]])<-groups[[i]]
}
### Rank-transform columns
ranks<-apply(signatures,2,rank,na.last="keep")
### Assign a 0 to signature weights where the signature was NA
sweights[is.na(ranks)]<-0
### 0-1 bound ranks
boundranks<-t(t(ranks)/(colSums(!is.na(signatures))+1))
# Treat bound ranks as quantiles in a gaussian distribution (0=-Inf, 1=+Inf)
gaussian <- qnorm(boundranks)
### Deal with NAs
gaussian[is.na(gaussian)]<-0
### Apply signature weights to the normalized distribution
gaussian<-gaussian*sweights
### Next, we see how each of the groups are behaving in these normalized
### signatures
### Create a boolean matrix with ngroup columns and signaturelength rows,
### indicating the matches
matches <- sapply(wgroups, function(group, allElements) {
hereMatches<-as.integer(allElements%in%names(group))
names(hereMatches)<-allElements
# Weigth by group belonging
weightedMatches<-hereMatches
weightedMatches[names(group)]<-weightedMatches[names(group)]*group
return(weightedMatches)
}, allElements=rownames(gaussian))
# And then transpose it
matches<-t(matches)
# Number of matches per group
groupmatches <- rowSums(matches)
# Relative part of the signature that matches
relativematches<-matches/groupmatches
# This trick will overweight massively small groups with all their
# components highly-ranked.
# Extreme case is with a group with one gene at the top
# The core linear algebra operation. The true magic of rea
enrichmentScore <- relativematches %*% gaussian
# Finally, every enrichment is square-rooted to respect the criterion
# of normality
normalizedEnrichmentScore<-enrichmentScore*sqrt(groupmatches)
# Return output
return(normalizedEnrichmentScore)
}
signatures<-setNames(-sort(rnorm(1000)),paste0("gene",1:1000))
set1<-paste0("gene",sample(1:200,50))
set2<-paste0("gene",sample(1:1000,50))
groups<-list(set1=set1,set2=set2)
obj<-rea(signatures=signatures,groups=groups)
obj
reflist<-setNames(-sort(rnorm(1000)),paste0("gene",1:1000))
set<-paste0("gene",sample(1:200,50))
obj<-gsea(reflist,set,method="pareto")
plot_gsea(obj)
zs<-c(1,-3,5,2,3)
ws<-c(1,10,1,2,1)
wstouffer(zs,ws)
ps<-c(0.01,0.05,0.03,0.2)
fisherp(ps)
example<-matrix(rnorm(1000),nrow=100,ncol=10)
set.seed(1)
example<-matrix(rnorm(1000),nrow=100,ncol=10)
slice(example)
set.seed(1)
a<-rnorm(1000)
b<-a+rnorm(1000)
r<-cor(a,b.method="pearson")
r<-cor(a,b,method="pearson")
corr2p(r,N=length(a))
b<-a+rnorm(1000,sd=10)
r<-cor(a,b,method="pearson")
corr2p(r,N=length(a))
N<-1000
p<-0.05
p2corr(p,N)
N<-100
p<-0.05
p2corr(p,N)
a<-rnorm(1000)
cols<-val2col(a)
?colorpanel
library(gplots)
a<-rnorm(1000)
cols<-val2col(a)
plot(a,col=cols,pch=20)
par(mfrow=c(1,1))
plot(a,col=cols,pch=20)
plot(a,col=cols,pch=16)
set.seed(1)
a<-runif(1000,0,1e9)
plot(a,xaxt="n")
plot(a,yaxt="n")
axis(2,at=pretty(a),labels=kmgformat(pretty(a)))
kmg<-kmgformat(pretty(a))
axis(2,at=pretty(a),labels=kmg)
set.seed(1)
a<-runif(1000,0,1e4)
plot(a,yaxt="n")
kmg<-kmgformat(pretty(a))
axis(2,at=pretty(a),labels=kmg)
a<-runif(1000,0,1e9)
plot(a,yaxt="n",pch=20,col=val2col(a))
val2col<-function(z,col1="navy",col2="white",col3="red3",nbreaks=100,center=TRUE,
rank=FALSE){
isMatrix<-FALSE
if(is.matrix(z)){
isMatrix<-TRUE
oriz<-z
}
if(is.character(z)){
z<-as.numeric(as.factor(z))
}
if(rank){
z<-rank(z)
}
if(center){
extreme=round(max(abs(z)))
breaks <- seq(-extreme, extreme, length = nbreaks)
z<-z-mean(z)
}else {
breaks <- seq(min(z), max(z), length = nbreaks)
}
ncol <- length(breaks) - 1
col <- colorpanel(ncol,col1,col2,col3)
CUT <- cut(z, breaks=breaks)
# assign colors to heights for each point
colorlevels <- col[match(CUT, levels(CUT))]
names(colorlevels)<-names(z)
if(isMatrix){
colormatrix<-matrix(colorlevels,ncol=ncol(oriz),nrow=nrow(oriz))
dimnames(colormatrix)<-dimnames(oriz)
return(colormatrix)
}
return(colorlevels)
}
set.seed(1)
a<-runif(1000,0,1e9)
plot(a,yaxt="n",pch=20,col=val2col(a))
kmg<-kmgformat(pretty(a))
axis(2,at=pretty(a),labels=kmg)
set.seed(1)
a<-rnorm(1000)
d<-density(a)
plot(d)
set.seed(1)
a<-rnorm(1000)
d<-density(a)
window<-c(2,3)
da<-density.auc(d,window)
plot(d,main="")
abline(v=window,lty=2)
title(paste0("AUC between lines=",da))
a<-setNames(rnorm(26),LETTERS)
b<-setNames(rnorm(26),LETTERS)
plot(a,b,pch=20,col="grey")
textplot2(a,b,words=LETTERS)
a<-setNames(rnorm(26),paste0(LETTERS,LETTERS,collapse="_"))
a<-setNames(rnorm(26*26),paste0(LETTERS,LETTERS,collapse="_"))
a
paste0(LETTERS,LETTERS,collapse="_")
paste0(LETTERS,LETTERS,sep="_")
obj_names<-apply(expand.grid(LETTERS,LETTERS),1,paste,collapse="_"))
obj_names<-apply(expand.grid(LETTERS,LETTERS),1,paste,collapse="_")
obj_names
a<-setNames(rnorm(26*26),obj_names)
b<-setNames(rnorm(26*26),obj_names)
plot(a,b,pch=20,col="grey")
textplot2(a,b,words=obj_names)
plot(a,b,pch=20,col="grey")
textplot2(a,b,words=obj_names,new=FALSE)
plot(a,b,pch=20,col="grey")
textplot2(a[1:100],b[1:100],words=obj_names,new=FALSE)
textplot2(a[1:100],b[1:100],words=obj_names[1:100],new=FALSE)
a<-setNames(runif(26*26),obj_names)
b<-setNames(runif(26*26),obj_names)
plot(a,b,pch=20,col="grey")
textplot2(a[1:100],b[1:100],words=obj_names[1:100],new=FALSE)
plot(a,b,pch=20,col="grey")
top<-which(sort(-a))[1:100]
textplot2(a[top],b[top],words=obj_names[top],new=FALSE)
top<-names(sort(-a))[1:100]
top
textplot2(a[top],b[top],words=top,new=FALSE)
b<-setNames(rnorm(26*26),obj_names)
plot(a,b,pch=20,col="grey")
top<-names(sort(-a))[1:50]
textplot2(a[top],b[top],words=top,new=FALSE)
obj_names<-apply(expand.grid(LETTERS,LETTERS),1,paste,collapse="")
a<-setNames(runif(26*26),obj_names)
b<-setNames(rnorm(26*26),obj_names)
plot(a,b,pch=20,col="grey")
top<-names(sort(-a))[1:50]
textplot2(a[top],b[top],words=top,new=FALSE,pointcolor="black")
vulcansheet()
sheetfile<-"deleteme.csv"
vulcansheet(sheetfile)
a<-read.csv(sheetfile)
a
bams<-a$bamReads
bams
a<-read.csv(sheetfile,as.is=TRUE)
bams<-a$bamReads
bams
average_fragment_length(bams,plot=TRUE)
document()
document()
library(vulcan)
library(BiocCheck)
BiocCheck("/Users/giorgi01/Dropbox/rstudio/vulcanpackage/vulcan")
library(vulcan)
library(BiocCheck)
BiocCheck("/Users/giorgi01/Dropbox/rstudio/vulcanpackage/vulcan")
library(devtools())
library(devtools
library(devtools)
document()
document()
library(vulcan)
?vulcan
source("https://bioconductor.org/biocLite.R")
biocLite()
install.packages("~/Dropbox/rstudio/vulcanpackage/vulcandata_0.99.0.tar.gz", repos = NULL, type = "source")
?gsea
?rea
?kmgformat
library(devtools)
document()
library(BiocCheck)
BiocCheck("/Users/giorgi01/Dropbox/rstudio/vulcanpackage/vulcan")
