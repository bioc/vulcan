{
    "collab_server" : "",
    "contents" : "#' z2p\n#'\n#' This function gives a gaussian p-value corresponding to the provided Z-score\n#'\n#' @param z a Z score\n#' @return a p-value\n#' @examples\n#' z<-1.96\n#' z2p(z)\n#' @export\nz2p<-function(z){\n    pnorm(abs(z), lower.tail=FALSE)*2\n}\n\n#' p2z\n#'\n#' This function gives a gaussian Z-score corresponding to the provided p-value\n#' Careful: sign is not provided\n#'\n#' @param p a p-value\n#' @return z a Z score\n#' @examples\n#' p<-0.05\n#' p2z(p)\n#' @export\np2z<-function(p){\n    qnorm(p/2, lower.tail=FALSE)\n}\n\n#' Stouffer integration of Z scores\n#'\n#' This function gives a gaussian Z-score corresponding to the provided p-value\n#' Careful: sign is not provided\n#'\n#' @param x a vector of Z scores\n#' @return Z an integrated Z score\n#' @examples\n#' zs<-c(1,3,5,2,3)\n#' stouffer(zs)\n#' @export\nstouffer<-function(x){\n    Z<-sum(x)/sqrt(length(x))\n    return(Z)\n}\n\n#' Weighted Stouffer integration of Z scores\n#'\n#' This function gives a gaussian Z-score corresponding to the provided p-value\n#' Careful: sign is not provided\n#'\n#' @param x a vector of Z scores\n#' @param w weight for each Z score\n#' @return Z an integrated Z score\n#' @examples\n#' zs<-c(1,-3,5,2,3)\n#' ws<-c(1,10,1,2,1)\n#' wstouffer(zs,ws)\n#' @export\nwstouffer<-function(x,w){\n    Z<-sum(x*w)/sqrt(sum(w^2))\n    return(Z)\n}\n\n\n#' Fisher integration of p-values\n#'\n#' This function applies the Fisher integration of pvalues\n#'\n#' @param x a vector of p-values\n#' @return p.val an integrated p-value\n#' @examples\n#' ps<-c(0.01,0.05,0.03,0.2)\n#' fisherp(ps)\n#' @export\nfisherp<-function(ps){\n    Xsq <- -2*sum(log(ps))\n    p.val <- pchisq(Xsq, df = 2*length(ps), lower.tail = FALSE)\n    #p<-c(Xsq = Xsq, p.value = p.val)\n    return(p.val)\n}\n\n\n#' Slice\n#'\n#' This function prints a slice of a matrix\n#'\n#' @param matrix A matrix\n#' @return prints it\n#' @examples\n#' set.seed(1)\n#' example<-matrix(rnorm(1000),nrow=100,ncol=10)\n#' slice(example)\n#' @export\nslice<-function(matrix){\n    if(nrow(matrix)<5){\n        stop(\"Input matrix has less than 5 rows\")\n    }\n    if(ncol(matrix)<5){\n        stop(\"Input matrix has less than 5 columns\")\n    }\n    print(matrix[1:5,1:5])\n}\n\n\n\n#' Convert correlation coefficient to p-value\n#'\n#' This functions converts an R value from a correlation calculation into a\n#' p-value, using a T distribution with the provided number of samples N minus\n#' 2 degrees of freedom\n#' @param r a correlation coefficient\n#' @param N a number of samples\n#' @return p a p-value\n#' @examples\n#' set.seed(1)\n#' a<-rnorm(1000)\n#' b<-a+rnorm(1000,sd=10)\n#' r<-cor(a,b,method=\"pearson\")\n#' corr2p(r,N=length(a))\n#' @export\ncorr2p<-function(r,N){\n    # Get the t-distribution value\n    t <- r / sqrt((1-r^2)/(N-2))\n    # t follows the t distribution with df=N?2\n    p <- 1-pt(abs(t),N-2)\n    return(p)\n}\n\n#' Convert p-value to correlation coefficient\n#'\n#' This functions converts an p-value into a the corresponding correlation\n#' coefficient, using a T distribution with the provided number of samples N\n#' minus 2 degrees of freedom\n#' @param p a p-value\n#' @param N a number of samples\n#' @return r a correlation coefficient\n#' @examples\n#' N<-100\n#' p<-0.05\n#' p2corr(p,N)\n#' @export\np2corr<-function(p,N){\n    # Get the t-value\n    t <- abs(qt(p,N-2))\n\n    # Convert to correlation\n    r <- sqrt( t^2 /(N-2+t^2) )\n\n    return(r)\n}\n\n\n#' Convert a numeric vector into colors\n#' @param z a vector of numbers\n#' @param col1 a color name for the min value, default \"navy\"\n#' @param col2 a color name for the middle value, default \"white\"\n#' @param col3 a color name for the max value, default \"red3\"\n#' @param nbreaks Number of colors to be generated. Default is 30.\n#' @param center boolean, should the data be centered? Default is TRUE\n#' @param rank boolean, should the data be ranked? Default is FALSE\n#' @return a vector of colors\n#' @examples\n#' a<-rnorm(1000)\n#' cols<-val2col(a)\n#' plot(a,col=cols,pch=16)\n#' @export\nval2col<-function(z,col1=\"navy\",col2=\"white\",col3=\"red3\",nbreaks=100,center=TRUE,\n                  rank=FALSE){\n    isMatrix<-FALSE\n    if(is.matrix(z)){\n        isMatrix<-TRUE\n        oriz<-z\n    }\n    if(is.character(z)){\n        z<-as.numeric(as.factor(z))\n    }\n    if(rank){\n        z<-rank(z)\n    }\n    if(center){\n        extreme=round(max(abs(z)))\n        breaks <- seq(-extreme, extreme, length = nbreaks)\n        z<-z-mean(z)\n    }else {\n        breaks <- seq(min(z), max(z), length = nbreaks)\n    }\n    ncol <- length(breaks) - 1\n    col <- colorpanel(ncol,col1,col2,col3)\n    CUT <- cut(z, breaks=breaks)\n    # assign colors to heights for each point\n    colorlevels <- col[match(CUT, levels(CUT))]\n    names(colorlevels)<-names(z)\n    if(isMatrix){\n        colormatrix<-matrix(colorlevels,ncol=ncol(oriz),nrow=nrow(oriz))\n        dimnames(colormatrix)<-dimnames(oriz)\n        return(colormatrix)\n    }\n    return(colorlevels)\n}\n\n#' kmgformat - Nice Formatting of Numbers\n#'\n#' This function will convert thousand numbers to K, millions to M, billions\n#' to G, trillions to T, quadrillions to P\n#'\n#' @param input A vector of values\n#' @param roundParam How many decimal digits you want\n#' @return A character vector of formatted numebr names\n#' @examples\n#' # Thousands\n#' set.seed(1)\n#' a<-runif(1000,0,1e4)\n#' plot(a,yaxt=\"n\")\n#' kmg<-kmgformat(pretty(a))\n#' axis(2,at=pretty(a),labels=kmg)\n#'\n#' # Millions to Billions\n#' set.seed(1)\n#' a<-runif(1000,0,1e9)\n#' plot(a,yaxt=\"n\",pch=20,col=val2col(a))\n#' kmg<-kmgformat(pretty(a))\n#' axis(2,at=pretty(a),labels=kmg)\n#' @export\nkmgformat<-function(input,roundParam=1){\n    signs<-sign(input)\n    signs[signs==1]<-\"\"\n    signs[signs==-1]<-\"-\"\n    absinput<-abs(input)\n    output<-c()\n    for(i in absinput){\n        if(i<1E3){\n            output<-c(output,i)\n        } else if (i<1E6){\n            i<-round(i/1E3,roundParam)\n            i<-paste0(i,\"K\")\n            output<-c(output,i)\n        } else if (i<1E9){\n            i<-round(i/1E6,roundParam)\n            i<-paste0(i,\"M\")\n            output<-c(output,i)\n        } else if (i<1E12){\n            i<-round(i/1E9,roundParam)\n            i<-paste0(i,\"G\")\n            output<-c(output,i)\n        } else if (i<1E15){\n            i<-round(i/1E12,roundParam)\n            i<-paste0(i,\"T\")\n            output<-c(output,i)\n        } else if (i<1E18){\n            i<-round(i/1E15,roundParam)\n            i<-paste0(i,\"P\")\n            output<-c(output,i)\n        } else {\n            output<-c(output,i)\n        }\n    }\n    output<-paste0(signs,output)\n    return(output)\n}\n\n\n\n#' density.auc - Calculate the AUC of a density object\n#'\n#' This function will calculate the AUC of a density object generated by the\n#' \\code{\"density\"} function.\n#'\n#' @param dens a density object\n#' @param window a vector with two values, specifying the left and right borders\n#' for the AUC to be calculated\n#' @return a numeric value for the density AUC\n#' @examples\n#' set.seed(1)\n#' a<-rnorm(1000)\n#' d<-density(a)\n#' window<-c(2,3)\n#' da<-density.auc(d,window)\n#'\n#' plot(d,main=\"\")\n#' abline(v=window,lty=2)\n#' title(paste0(\"AUC between lines=\",da))\n#'\n#'\n#'\n#' @export\ndensity.auc<-function(dens,window){\n    xt<-diff(dens$x[dens$x>window[1]&dens$x<window[2]])\n    yt<-rollmean(dens$y[dens$x>window[1]&dens$x<window[2]],2)\n    sum(xt*yt)\n}\n\n\n\n#' textplot2 - An x y plot of non-overlapping text\n#'\n#' This function is an extension of the \\code{\"textplot\"} function from the\n#' \\code{\"wordcloud\"} package, with the extra functionality of specifiying the\n#' color of the points\n#' @param x x coordinates\n#' @param y y coordinates\n#' @param words the text to plot\n#' @param cex font size\n#' @param new should a new plot be created\n#' @param pointcolor a string specifying the color of the points\n#' (default #FFFFFF00)\n#' @param show.lines if true, then lines are plotted between x,y and the word,\n#' for those words not covering their x,y coordinates\n#' @param ...    Additional parameters to be passed to wordlayout and text.\n#' @return nothing\n#' @examples\n#' obj_names<-apply(expand.grid(LETTERS,LETTERS),1,paste,collapse=\"\")\n#' a<-setNames(runif(26*26),obj_names)\n#' b<-setNames(rnorm(26*26),obj_names)\n#' plot(a,b,pch=20,col=\"grey\")\n#' top<-names(sort(-a))[1:50]\n#' textplot2(a[top],b[top],words=top,new=FALSE,pointcolor=\"black\")\n#' @export\ntextplot2<-function(x,y,words,cex=1,pch = 16,pointcolor=\"#FFFFFF00\",\n                    new=TRUE,show.lines=TRUE,...){\n    if(new){\n        plot(x,y,type=\"n\",...)\n    }\n    lay <- wordlayout(x,y,words,cex,...)\n    if(show.lines){\n        for(i in 1:length(x)){\n            xl <- lay[i,1]\n            yl <- lay[i,2]\n            w <- lay[i,3]\n            h <- lay[i,4]\n            if(x[i]<xl || x[i]>xl+w || y[i]<yl || y[i]>yl+h){\n                points(x[i],y[i],pch= pch,col= pointcolor,cex= .5)\n                nx <- xl+.5*w\n                ny <- yl+.5*h\n                lines(c(x[i],nx),c(y[i],ny),col=\"grey\")\n            }\n        }\n    }\n    text(lay[,1]+.5*lay[,3],lay[,2]+.5*lay[,4],words,cex = cex,...)\n}\n\n#' Define the average fragment length\n#'\n#' A function to get average fragment length from a ChIP-Seq experiment\n#' @param bam.files a vector of BAM files locations\n#' @param plot logical. Should a plot be generated?\n#' @param max.dist numeric. Maximum fragment length accepted. Default=550\n#' @return nothing\n#' @examples\n#' sheetfile<-\"deleteme.csv\"\n#' vulcansheet(sheetfile)\n#' a<-read.csv(sheetfile,as.is=TRUE)\n#' bams<-a$bamReads\n#' unlink(sheetfile)\n#' average_fragment_length(bams,plot=TRUE)\n#' @export\naverage_fragment_length<- function(bam.files,plot=TRUE,max.dist=550) {\n    # obtain average fragment length from cross-correlation of plus/minus strand\n    # alignments\n    x<-csaw::correlateReads(bam.files,max.dist=max.dist)\n    # visualize (raw and smoothed)\n    xs<-caTools::runmean(Rle(x),k=101,endrule=\"constant\")\n    frag.len<-which.max(xs)\n    if(plot){\n        plot(0:max.dist,x,pch=\"*\",ylab=\"CCF\",xlab=\"Delay (bp)\")\n        lines(0:max.dist,xs,col=\"red\",lwd=3)\n        abline(v = frag.len, col = \"blue\")\n        legend(\"topright\", paste0(\"fragment-length = \", frag.len, \"bp\"),\n               bty = \"n\")\n    }\n    return(frag.len)\n}\n\n",
    "created" : 1493987994554.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1204165136",
    "id" : "7E785765",
    "lastKnownWriteTime" : 1495649695,
    "last_content_update" : 1495649695096,
    "path" : "~/Dropbox/rstudio/vulcanpackage/vulcan/R/generic.R",
    "project_path" : "R/generic.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}