{
    "collab_server" : "",
    "contents" : "#' GSEA\n#'\n#' This function performs Gene Set Enrichment Analysis\n#'\n#' @param reflist named vector of reference scores\n#' @param set element set\n#' @param method one of \"permutation\" or \"pareto\"\n#' @param w weight\n#' @param gsea_null a GSEA null distribution (Optional)\n#' @return A GSEA object. Basically a list of s components:\n#' \\describe{\n#' \\item{ES}{The enrichment score}\n#' \\item{NES}{The normalized enrichment socre}\n#' \\item{ledge}{The items in the leading edge}\n#' \\item{p.value}{The permutation-based p-value}\n#' }\n#' @examples\n#' reflist<-setNames(-sort(rnorm(1000)),paste0(\"gene\",1:1000))\n#' set<-paste0(\"gene\",sample(1:200,50))\n#' obj<-gsea(reflist,set,method=\"pareto\")\n#' obj$p.value\n#' @export\ngsea <- function(reflist,\n                 set,\n                 method=c(\"permutation\",\"pareto\"),\n                 np=1000,\n                 w=1,\n                 gsea_null=NULL) {\n\n\n    # Get elements in set that are in the ref list\n    set <- intersect(names(reflist), set)\n\n    # Sort the reference list\n    # Get the list order, from higher (1) to smaller (n)\n    ix <- order(reflist, decreasing=TRUE)\n    reflist <- reflist[ix] # Reorder the reference list\n\n    # Initialize variables for running sum\n    es <- 0\n    nes <- 0\n    p.value <- 1\n\n    # Identify indexes of set within the sorted reference list\n    inSet <- rep(0, length(reflist))\n    inSet[which(names(reflist) %in% set)] <- 1\n\n    ### Compute Enrichment Score\n    # Compute running sum for hits\n    hits<-abs(reflist*inSet) # Get the values for the elements in the set\n    hits<-hits^w # Raise this score to the power of w\n    score_hit <- cumsum(hits) # Cumulative sum of hits' scores\n    # The cumulative sum is divided by the final sum value\n    score_hit <- score_hit / score_hit[length(score_hit)]\n\n    # Compute running sum for non-hits\n    score_miss <- cumsum(1-inSet)\n    score_miss <- score_miss/score_miss[length(score_miss)]\n\n    # The Running Score is the difference between the two scores! Hits - nonhits\n    running_score <- score_hit - score_miss\n\n    # Safety measure, in the case the random genes have all a weight of 0\n    if(all(is.na(running_score))){\n        running_score<-rep(0,length(running_score))\n    }\n\n    # The ES is actually the minimum or maximum Running Scores\n    if(abs(max(running_score))>abs(min(running_score))){\n        es<-max(running_score)\n    } else {\n        es<-min(running_score)\n    }\n\n\n    ### Identify leading edge\n    # Create a vector of 0s long as the reference list\n    ledge_indeces <- rep(0, length(running_score))\n    # Case 1: negative ES\n    if (es<0){\n        peak <- which(running_score==min(running_score))[1]\n        ledge_indeces[peak:length(ledge_indeces)] <- 1 # Leading edge is\n        # stuff AFTER the peak point (ES is negative)\n        ledge_indeces <- which(ledge_indeces == 1)\n        ledge_names <- names(reflist[ledge_indeces])\n    } else{ # Case 2: positive ES\n        peak <- which(running_score==max(running_score)) # Define the peak point\n        # Leading edge is stuff BEFORE the peak point (ES is positive)\n        ledge_indeces[1:peak] <- 1\n        ledge_indeces <- which(ledge_indeces == 1)\n        ledge_names <- names(reflist[ledge_indeces])\n    }\n\n\n\n\n\n    ### Compute p-value by permutation\n    if(is.null(gsea_null)){\n        null_es<-null_gsea(set=set,reflist=reflist,np=np,w=w)\n    } else{\n        ### If a null list is provided, use it\n        if(class(gsea_null)==\"gsea_nullist\"){\n            null_es<-gsea_null[as.character(length(set))][[1]]\n        }else{\n            null_es<-gsea_null\n        }\n    }\n    # The empirical p-value will be calculated\n    #    if (es<0){\n    #        p.value <- sum(null_es<=es)/length(which(null_es<0))\n    #    } else {\n    #        p.value <- sum(null_es>=es)/length(which(null_es>0))\n    #    }\n    #    # NaN cases (no null stronger than es, no null with the right sign)\n    #    if(is.na(p.value)){\n    if (es<0){\n        p.value <- sum(null_es<=es)/length(null_es)\n    } else {\n        p.value <- sum(null_es>=es)/length(null_es)\n    }\n    #    }\n\n\n    # If we are in the tail, the p-value can be calculated in two ways\n    if(is.na(p.value) || p.value<0.05) {\n        if(p.value==0){\n            p.value <- 1/np\n        }\n        if (method==\"pareto\"){\n            # Extract the absolute null ESs above the 95th percentile\n            q95<-as.numeric(quantile(abs(null_es),0.95))\n            fit<-pareto.fit(abs(null_es),threshold=q95)\n            newp.value<-ppareto(abs(es), threshold=q95, exponent=fit$exponent,\n                                lower.tail=FALSE)/20\n            # Brutal fix, if Pareto cannot fix small ESs,\n            # take the permutation p-value\n            if(is.na(newp.value)){\n                newp.value<-p.value\n            }\n            p.value<-newp.value\n        }\n    }\n\n    # Calculate the normalized enrichment score\n    nes<-p2z(p.value)*sign(es)\n\n    gsea.obj<-list(\n        es=es,\n        nes=nes,\n        p.value=p.value,\n        ledge=ledge_names,\n        running_score=running_score,\n        set=set,\n        reflist=reflist,\n        inSet=inSet\n    )\n    class(gsea.obj)<-\"gsea\"\n    return(gsea.obj)\n}\n\n\n#' Calculate Null Distribution for GSEA\n#'\n#' This function generates a GSEA null distribution from\n#'\n#' @param set A vector containing gene names.\n#' @param reflist A named vector containing the weights of the entire signature\n#' @param np Number of permutations (Default: 1000)\n#' @return A vector of null scores appropriate for the set/reflist combination\n#' provided\n#' @examples\n#' reflist<-setNames(-sort(rnorm(26)),LETTERS)\n#' set<-c(\"A\",\"B\",\"D\",\"F\")\n#' nulldist<-null_gsea(set,reflist)\n#' nulldist[1:10]\n#' @export\nnull_gsea<-function(set,reflist,w=1,np=1000){\n    gsea_null <- rep(0, np)\n    gsea_null <- sapply(1:np, function(i) {\n        # Identify indexes of set within the sorted reference list\n        inSet <- rep(0, length(reflist))\n        inSet[which(names(reflist) %in% set)] <- 1\n\n        # By sampling the order of the set elements, we get the real permutation\n        null_inSet <- inSet[sample(1:length(inSet))]\n\n        # Same as before, cumulative sums of hits and nonhits\n        null_hit<-abs(reflist*null_inSet)\n        null_hit<-null_hit^w\n        null_hit <- cumsum(null_hit)\n        null_hit <- null_hit/null_hit[length(null_hit)]\n        null_miss <- cumsum(1-null_inSet)\n        null_miss <- null_miss/null_miss[length(null_miss)]\n        # And dependending on the cumulative sums, null running sum and null\n        # enrichment score\n        null_running_score <- null_hit - null_miss\n\n        # The ES is just he maximum or the minimum\n        if(abs(max(null_running_score))>abs(min(null_running_score))){\n            null_es<-max(null_running_score)\n        } else {\n            null_es<-min(null_running_score)\n        }\n        return(null_es)\n    })\n    class(gsea_null)<-\"gsea_null\"\n    return(gsea_null)\n}\n#' Plot GSEA results\n#'\n#' This function generates a GSEA plot from a gsea object\n#'\n#' @param gsea.obj GSEA object produced by the \\code{gsea} function\n#' @param twoColors the two colors to use for positive[1] and negative[2]\n#' enrichment scores\n#' @param colBarcode The color of the barcode\n#' @param plotNames Logical. Should the set names be plotted?\n#' @param title String to be plotted above the Running Enrichment Score\n#' @param correctEntrez Logical. Should the ids converted to gene symbols?\n#' @param bottomYlabel String for the label\n#' @param ext_nes Provide a NES from an external calculation\n#' @param omit_middle If TRUE, will not plot the running score\n#' (FALSE by default)\n#' @return Nothing, a plot is generated in the default output device\n#' @examples\n#' reflist<-setNames(-sort(rnorm(26)),LETTERS)\n#' set<-c(\"A\",\"B\",\"D\",\"F\")\n#' obj<-gsea(reflist,set,method=\"pareto\")\n#' plot_gsea(obj)\n#' @export\nplot_gsea<-function(\n    gsea.obj,\n    twoColors=c(\"red\",\"blue\"),\n    plotNames=FALSE,\n    colBarcode=\"black\",\n    title=\"Running Enrichment Score\",\n    correctEntrez=FALSE,\n    bottomYtitle=\"List Values\",\n    bottomYlabel=\"Signature values\",\n    ext_nes=NULL,\n    omit_middle=FALSE\n) {\n    # Extract parameters from the gsea object\n    es<-gsea.obj$es\n    nes<-gsea.obj$nes\n    p.value<-gsea.obj$p.value\n    ledge<-gsea.obj$ledge\n    running_score<-gsea.obj$running_score\n    set<-gsea.obj$set\n    reflist<-gsea.obj$reflist\n    inSet<-gsea.obj$inSet\n\n    # Convert to gene symbols\n    if(correctEntrez){\n        set<-e2s(set)\n        names(reflist)<-e2s(names(reflist))\n    }\n\n\n    # Define plot borders? Who wrote the original code has a non-euclidean mind\n    min.RES <- min(running_score)\n    max.RES <- max(running_score)\n    #    if (max.RES < 0.3){\n    #        max.RES <- 0.3\n    #    }\n    #    if (min.RES > -0.3) {\n    #        min.RES <- -0.3\n    #    }\n    delta <- (max.RES - min.RES)*0.50\n    min.plot <- min.RES\n    max.plot <- max.RES\n    max.corr <- max(reflist)\n    min.corr <- min(reflist)\n    Obs.correl.vector.norm<-(reflist - min.corr)/\n        (max.corr - min.corr)*1.25*delta + min.plot\n    zero.corr.line <- (- min.corr/(max.corr - min.corr))*1.25*delta + min.plot\n\n    if(es<0) {\n        l.ledge.ref.plot <- length(reflist)-length(ledge)\n    } else {\n        l.ledge.ref.plot <- length(ledge)\n    }\n\n    # Define colors (red is positive nes, blue is negative nes)\n    if(nes>0) {\n        col.f <- twoColors[1]\n    } else {\n        col.f <- twoColors[2]\n    }\n    N<-length(reflist)\n    ind <- 1:N\n\n\n    ### Define layout, let's end this destructive putting\n    ### everything in a single window\n    if(omit_middle){\n        layoutMatrix<-rbind(1,2)\n        layout(layoutMatrix,heights=c(1,2))\n    } else {\n        layoutMatrix<-rbind(1,2,3)\n        layout(layoutMatrix,heights=c(1,4,2))\n    }\n\n\n    #layout.show(n=3)\n\n    ### PLOT 1: barcode-like enrichment tags\n    par(mar=c(0,4.1,2,2.1))\n    plot(0,\n         col=\"white\",\n         xlim=c(1, N),\n         ylim=c(0,10),\n         xaxt=\"n\",\n         yaxt=\"n\",\n         type=\"n\",\n         frame.plot=FALSE,\n         xlab=\"\",\n         ylab=\"\",\n         xaxs=\"r\",\n         yaxs=\"r\",\n         main=paste(\"Number of elements: \", N,\n                    \" (in full list), \",\n                    length(set), \" (in element set)\", sep = \"\", collapse=\"\")\n    )\n    for (position in 1:N) {\n        if (inSet[position]  == 1) {\n            if(N<50&length(set)<=10){\n                rect(\n                    xleft=position-0.2,\n                    ybottom=0,\n                    xright=position+0.2,\n                    ytop=10,\n                    col=colBarcode,\n                    border=NA\n                )\n            } else{\n                abline(v=position,lwd=2,col=colBarcode)\n            }\n            if(plotNames){\n                text(\n                    labels=names(reflist[position]),\n                    x=position-0.2,\n                    y=0,\n                    srt=90,\n                    offset=0,\n                    pos=4,\n                    font=2\n                )\n            }\n        }\n    }\n\n    ### PLOT 2: The running sum plot\n    if(!omit_middle){\n        par(mar=c(2,4.1,2,2.1))\n        plot(ind,\n             running_score,\n             sub = \"\",\n             xlab=\"\",\n             ylab=\"Enrichment Score\",\n             xlim=c(1, N),\n             ylim=c(min.plot, max.plot),\n             type = \"l\",\n             pch=20,\n             lwd = 4,\n             cex = 1,\n             col = col.f,\n             xaxs=\"r\",\n             yaxs=\"r\",\n             main=title\n        )\n        grid(col=\"dark grey\",lty=2)\n\n        # This is important: zero running score line\n        lines(c(1, N), c(0, 0), lwd = 1, lty = 1, cex = 1)\n\n        # This is also important: it's the max enrichment vertical line (aka LEADING EDGE)\n        lines(c(l.ledge.ref.plot, l.ledge.ref.plot),\n              c(min.plot, max.plot), lwd = 1, lty = 1, cex = 1)\n\n        if(es>=0){\n            legend_position<-\"topright\"\n        }else{\n            legend_position<-\"topleft\"\n        }\n\n        # If an external NES is not provided, the standard GSEA one is shown\n        if(is.null(ext_nes)){\n            legend(legend_position,legend=c(paste(\"ES = \",signif(es,3),sep=\"\"),\n                                            paste(\"NES = \",signif(nes,3),sep=\"\"),paste(\"p-value = \",signif(p.value,3),sep=\"\")),bg=\"white\")\n        } else {\n            legend(legend_position,legend=c(paste(\"NES = \",\n                                                  signif(ext_nes,3),sep=\"\"),\n                                            paste(\"p-value = \",\n                                                  signif(z2p(ext_nes),3),\n                                                  sep=\"\")),bg=\"white\")\n        }\n    }\n\n\n    ### Plot3:  weight values\n    if(omit_middle){\n        bottomMain<-title\n    }else{\n        bottomMain<-bottomYtitle\n    }\n\n    par(mar=c(2,4.1,2,2.1))\n    plot(ind,\n         reflist,\n         type = \"l\",\n         pch=20,\n         lwd = 3,\n         xlim=c(1, N),\n         cex = 1,\n         col = 1,\n         xaxs=\"r\",\n         yaxs=\"r\",\n         main=bottomMain,\n         ylab=bottomYlabel,\n         cex.axis=0.8\n    )\n    grid(col=\"dark grey\",lty=2)\n    lines(c(1, N), c(zero.corr.line, zero.corr.line),\n          lwd = 1, lty = 1, cex = 1, col = 1) # zero correlation horizontal line\n\n    if(omit_middle){\n        # If an external NES is not provided, the standard GSEA one is shown\n        if(is.null(ext_nes)){\n            legend(\"top\",legend=c(paste(\"ES = \",signif(es,3),sep=\"\"),\n                                  paste(\"NES = \",signif(nes,3),sep=\"\"),\n                                  paste(\"p-value = \",signif(p.value,3),sep=\"\")),\n                   bg=\"white\")\n        } else {\n            legend(\"top\",legend=c(paste(\"NES = \",\n                                        signif(ext_nes,3),sep=\"\"),\n                                  paste(\"p-value = \",\n                                        signif(z2p(ext_nes),3),sep=\"\")),\n                   bg=\"white\")\n        }\n    }\n\n}\n\n\n\n#' Probability density of Pareto distributions\n#'\n#' Gives NA on values below the threshold\n#'\n#' @param x Data vector of log probability densities\n#' @return Vector of (log) probability densities\n#' @examples\n#' set.seed(1)\n#' x<-abs(rnorm(1000))\n#' n<-length(x)\n#' exponent<-1+n/sum(log(x))\n#' dp<-dpareto(x,exponent=exponent)\n#' plot(dp)\n#' @export\ndpareto <- function(x, threshold = 1, exponent, log=FALSE) {\n    # Avoid doing limited-precision arithmetic followed by logs if we want\n    # the log!\n    if (!log) {\n        prefactor <- (exponent-1)/threshold\n        f <- function(x) {prefactor*(x/threshold)^(-exponent)}\n    } else {\n        prefactor.log <- log(exponent-1) - log(threshold)\n        f <- function(x) {prefactor.log -exponent*(log(x) - log(threshold))}\n    }\n    d <- ifelse(x<threshold,NA,f(x))\n    return(d)\n}\n\n#' Cumulative distribution function of the Pareto distributions\n#' '\n#' Gives NA on values < threshold\n#' @param x Data vector, lower threshold, scaling exponent, usual flags\n#' @return Vector of (log) probabilities\n#' @examples\n#' # Estimate the tail of a pospulation normally distributed\n#' set.seed(1)\n#' x<-rnorm(1000)\n#' q95<-as.numeric(quantile(abs(x),0.95))\n#' fit<-pareto.fit(abs(x),threshold=q95)\n#' # We can infer the pvalue of a value very much right to the tail of the\n#' # distribution\n#' value<-5\n#' pvalue<-ppareto(value, threshold=q95, exponent=fit$exponent,\n#' lower.tail=FALSE)/20\n#' plot(density(abs(x)),xlim=c(0,value+0.3),main=\"Pareto fit\")\n#' arrows(value,0.2,value,0)\n#' text(value,0.2,labels=paste0(\"p=\",signif(pvalue,2)))\n#' @export\nppareto <- function(x, threshold=1, exponent, lower.tail=TRUE) {\n    if (!lower.tail) {\n        f <- function(x) {(x/threshold)^(1-exponent)}\n    }\n    if (lower.tail) {\n        f <- function(x) { 1 - (x/threshold)^(1-exponent)}\n    }\n    p <- ifelse(x < threshold, NA, f(x))\n    return(p)\n}\n\n#' Estimate parameters of Pareto distribution\n#'\n#' A wrapper for functions implementing actual methods\n#' @param data data vector, lower threshold (or \"find\", indicating it should be\n#' found from the data), method (likelihood or regression, defaulting to former)\n#' @return List indicating type of distribution (\"pareto\"), parameters,\n#' information about fit (depending on method), OR a warning and NA if method\n#' is not recognized\n#' @examples\n#' # Estimate the tail of a pospulation normally distributed\n#' set.seed(1)\n#' x<-rnorm(1000)\n#' q95<-as.numeric(quantile(abs(x),0.95))\n#' fit<-pareto.fit(abs(x),threshold=q95)\n#' # We can infer the pvalue of a value very much right to the tail of the\n#' # distribution\n#' value<-5\n#' pvalue<-ppareto(value, threshold=q95, exponent=fit$exponent,\n#' lower.tail=FALSE)/20\n#' plot(density(abs(x)),xlim=c(0,value+0.3),main=\"Pareto fit\")\n#' arrows(value,0.2,value,0)\n#' text(value,0.2,labels=paste0(\"p=\",signif(pvalue,2)))\n#' @export\npareto.fit <- function(data, threshold) {\n    data <- data[data>=threshold]\n    n <- length(data)\n    x <- data/threshold\n    alpha <- 1 + n/sum(log(x))\n    # Calculate Log-Likelihood\n    loglike <- sum(dpareto(data, threshold = threshold, exponent = alpha, log = TRUE))\n    # KS distance\n    newdata <- data[data>=threshold]\n    d<-suppressWarnings(ks.test(newdata,ppareto,threshold=threshold,\n                                exponent=alpha))\n    ks.dist<-as.vector(d$statistic)\n    fit <- list(type=\"pareto\", exponent=alpha, xmin=threshold, loglike=loglike,\n                ks.dist = ks.dist, samples.over.threshold=n)\n    return(fit)\n}\n\n\n",
    "created" : 1495459732774.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1194215188",
    "id" : "CA9EF7C3",
    "lastKnownWriteTime" : 1495649771,
    "last_content_update" : 1495649771049,
    "path" : "~/Dropbox/rstudio/vulcanpackage/vulcan/R/gsea.R",
    "project_path" : "R/gsea.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}