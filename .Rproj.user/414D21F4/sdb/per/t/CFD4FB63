{
    "collab_server" : "",
    "contents" : "#' GSEA\n#'\n#' This function performs Gene Set Enrichment Analysis\n#'\n#' @param reflist named vector of reference scores\n#' @param set element set\n#' @param type one of \"permutation\" or \"pareto\"\n#' @param w weight\n#' @param gsea_null a GSEA null distribution (Optional)\n#' @return A GSEA object. Basically a list of s components:\n#' \\describe{\n#' \\item{ES}{The enrichment score}\n#' \\item{NES}{The normalized enrichment socre}\n#' \\item{ledge}{The items in the leading edge}\n#' \\item{p.value}{The permutation-based p-value}\n#' }\n#' @export\ngsea <- function(reflist,\n                 set,\n                 method=c(\"permutation\",\"pareto\"),\n                 np=1000,\n                 w=1,\n                 gsea_null=NULL) {\n\n\n  # Get elements in set that are in the ref list\n  set <- intersect(names(reflist), set)\n\n  # Sort the reference list\n  ix <- order(reflist, decreasing=T) # Get the list order, from higher (1) to smaller (n)\n  reflist <- reflist[ix] # Reorder the reference list\n\n  # Initialize variables for running sum\n  es <- 0\n  nes <- 0\n  p.value <- 1\n\n  # Identify indexes of set within the sorted reference list\n  inSet <- rep(0, length(reflist))\n  inSet[which(names(reflist) %in% set)] <- 1\n\n  ### Compute Enrichment Score\n  # Compute running sum for hits\n  hits<-abs(reflist*inSet) # Get the values for the elements in the set\n  hits<-hits^w # Raise this score to the power of w\n  score_hit <- cumsum(hits) # Cumulative sum of hits' scores\n  score_hit <- score_hit / score_hit[length(score_hit)] # The cumulative sum is divided by the final  sum value\n\n  # Compute running sum for non-hits\n  score_miss <- cumsum(1-inSet)\n  score_miss <- score_miss/score_miss[length(score_miss)]\n\n  # The Running Score is the difference between the two scores! Hits - nonhits\n  running_score <- score_hit - score_miss\n\n  # Safety measure, in the case the random genes have all a weight of 0\n  if(all(is.na(running_score))){\n    running_score<-rep(0,length(running_score))\n  }\n\n  # The ES is actually the minimum or maximum Running Scores\n  if(abs(max(running_score))>abs(min(running_score))){\n    es<-max(running_score)\n  } else {\n    es<-min(running_score)\n  }\n\n\n  ### Identify leading edge\n  ledge_indeces <- rep(0, length(running_score)) # Create a vector of 0s long as the reference list\n  # Case 1: negative ES\n  if (es<0){\n    peak <- which(running_score==min(running_score))[1]\n    ledge_indeces[peak:length(ledge_indeces)] <- 1 # Leading edge is stuff AFTER the peak point (ES is negative)\n    ledge_indeces <- which(ledge_indeces == 1)\n    ledge_names <- names(reflist[ledge_indeces])\n  } else{ # Case 2: positive ES\n    peak <- which(running_score==max(running_score)) # Define the peak point\n    ledge_indeces[1:peak] <- 1 # Leading edge is stuff BEFORE the peak point (ES is positive)\n    ledge_indeces <- which(ledge_indeces == 1)\n    ledge_names <- names(reflist[ledge_indeces])\n  }\n\n\n\n\n\n  ### Compute p-value by permutation\n  if(is.null(gsea_null)){\n    null_es<-null_gsea(set=set,reflist=reflist,np=np,w=w)\n  } else{\n    ### If a null list is provided, use it\n    if(class(gsea_null)==\"gsea_nullist\"){\n      null_es<-gsea_null[as.character(length(set))][[1]]\n    }else{\n      null_es<-gsea_null\n    }\n  }\n  # The empirical p-value will be calculated\n  #\tif (es<0){\n  #\t\tp.value <- sum(null_es<=es)/length(which(null_es<0))\n  #\t} else {\n  #\t\tp.value <- sum(null_es>=es)/length(which(null_es>0))\n  #\t}\n  #\t# NaN cases (no null stronger than es, no null with the right sign)\n  #\tif(is.na(p.value)){\n  if (es<0){\n    p.value <- sum(null_es<=es)/length(null_es)\n  } else {\n    p.value <- sum(null_es>=es)/length(null_es)\n  }\n  #\t}\n\n\n  # If we are in the tail, the p-value can be calculated in two ways\n  if(is.na(p.value) || p.value<0.05) {\n    if(p.value==0){\n      p.value <- 1/np\n    }\n    if (method==\"pareto\"){\n      # Extract the absolute null ESs above the 95th percentile\n      q95<-as.numeric(quantile(abs(null_es),0.95))\n      fit<-pareto.fit(abs(null_es),threshold=q95)\n      newp.value<-ppareto(abs(es), threshold=q95, exponent=fit$exponent, lower.tail=FALSE)/20\n      # Brutal fix, if Pareto cannot fix small ESs, take the permutation p-value\n      if(is.na(newp.value)){\n        newp.value<-p.value\n      }\n      p.value<-newp.value\n    }\n  }\n\n  # Calculate the normalized enrichment score\n  nes<-p2z(p.value)*sign(es)\n\n  gsea.obj<-list(\n    es=es,\n    nes=nes,\n    p.value=p.value,\n    ledge=ledge_names,\n    running_score=running_score,\n    set=set,\n    reflist=reflist,\n    inSet=inSet\n  )\n  class(gsea.obj)<-\"gsea\"\n  return(gsea.obj)\n}\n\n\n#' Calculate Null Distribution for GSEA\n#'\n#' This function generates a GSEA null distribution from\n#'\n#' @param set A vector containing gene names.\n#' @param reflist A named vector containing the weights of the entire signature\n#' @param np Number of permutations\n#' @return A gsea_null object\n#' @export\nnull_gsea<-function(set,reflist,w=1,np=1000){\n  gsea_null <- rep(0, np)\n  gsea_null <- sapply(1:np, function(i) {\n    # Identify indexes of set within the sorted reference list\n    inSet <- rep(0, length(reflist))\n    inSet[which(names(reflist) %in% set)] <- 1\n\n    null_inSet <- inSet[sample(1:length(inSet))] # By sampling the order of the set elements, we get the real permutation\n\n    # Same as before, cumulative sums of hits and nonhits\n    null_hit<-abs(reflist*null_inSet)\n    null_hit<-null_hit^w\n    null_hit <- cumsum(null_hit)\n    null_hit <- null_hit/null_hit[length(null_hit)]\n    null_miss <- cumsum(1-null_inSet)\n    null_miss <- null_miss/null_miss[length(null_miss)]\n    # And dependending on the cumulative sums, null running sum and null enrichment score\n    null_running_score <- null_hit - null_miss\n\n    # The ES is just he maximum or the minimum\n    if(abs(max(null_running_score))>abs(min(null_running_score))){\n      null_es<-max(null_running_score)\n    } else {\n      null_es<-min(null_running_score)\n    }\n    return(null_es)\n  })\n  class(gsea_null)<-\"gsea_null\"\n  return(gsea_null)\n}\n#' Plot GSEA results\n#'\n#' This function generates a GSEA plot from a gsea object\n#'\n#' @param gsea.obj GSEA object produced by the \\code{gsea} function\n#' @param twoColors the two colors to use for positive[1] and negative[2] enrichment scores\n#' @param colBarcode The color of the barcode\n#' @param plotNames Logical. Should the set names be plotted?\n#' @param title String to be plotted above the Running Enrichment Score\n#' @param correctEntrez Logical. Should the ids converted to gene symbols?\n#' @param bottomYlabel String for the label\n#' @param ext_nes Provide a NES from an external calculation\n#' @param omit_middle If TRUE, will not plot the running score (FALSE by default)\n#' @return Nothing, a plot is generated in the default output device\n#' @export\nplot_gsea<-function(\n  gsea.obj,\n  twoColors=c(\"red\",\"blue\"),\n  plotNames=FALSE,\n  colBarcode=\"black\",\n  title=\"Running Enrichment Score\",\n  correctEntrez=FALSE,\n  bottomYtitle=\"List Values\",\n  bottomYlabel=\"Signature values\",\n  ext_nes=NULL,\n  omit_middle=FALSE\n) {\n  # Extract parameters from the gsea object\n  es<-gsea.obj$es\n  nes<-gsea.obj$nes\n  p.value<-gsea.obj$p.value\n  ledge<-gsea.obj$ledge\n  running_score<-gsea.obj$running_score\n  set<-gsea.obj$set\n  reflist<-gsea.obj$reflist\n  inSet<-gsea.obj$inSet\n\n  # Convert to gene symbols\n  if(correctEntrez){\n    set<-e2s(set)\n    names(reflist)<-e2s(names(reflist))\n  }\n\n\n  # Define plot borders? Who wrote the original code has a non-euclidean mind\n  min.RES <- min(running_score)\n  max.RES <- max(running_score)\n  #\tif (max.RES < 0.3){\n  #\t\tmax.RES <- 0.3\n  #\t}\n  #\tif (min.RES > -0.3) {\n  #\t\tmin.RES <- -0.3\n  #\t}\n  delta <- (max.RES - min.RES)*0.50\n  min.plot <- min.RES\n  max.plot <- max.RES\n  max.corr <- max(reflist)\n  min.corr <- min(reflist)\n  Obs.correl.vector.norm <- (reflist - min.corr)/(max.corr - min.corr)*1.25*delta + min.plot\n  zero.corr.line <- (- min.corr/(max.corr - min.corr))*1.25*delta + min.plot\n\n  if(es<0) {\n    l.ledge.ref.plot <- length(reflist)-length(ledge)\n  } else {\n    l.ledge.ref.plot <- length(ledge)\n  }\n\n  # Define colors (red is positive nes, blue is negative nes)\n  if(nes>0) {\n    col.f <- twoColors[1]\n  } else {\n    col.f <- twoColors[2]\n  }\n  N<-length(reflist)\n  ind <- 1:N\n\n\n  ### Define layout, let's end this destructive putting everything in a single window\n  if(omit_middle){\n    layoutMatrix<-rbind(1,2)\n    layout(layoutMatrix,heights=c(1,2))\n  } else {\n    layoutMatrix<-rbind(1,2,3)\n    layout(layoutMatrix,heights=c(1,4,2))\n  }\n\n\n  #layout.show(n=3)\n\n  ### PLOT 1: barcode-like enrichment tags\n  par(mar=c(0,4.1,2,2.1))\n  plot(0,\n       col=\"white\",\n       xlim=c(1, N),\n       ylim=c(0,10),\n       xaxt=\"n\",\n       yaxt=\"n\",\n       type=\"n\",\n       frame.plot=FALSE,\n       xlab=\"\",\n       ylab=\"\",\n       xaxs=\"r\",\n       yaxs=\"r\",\n       main=paste(\"Number of elements: \", N, \" (in full list), \", length(set), \" (in element set)\", sep = \"\", collapse=\"\")\n  )\n  for (position in 1:N) {\n    if (inSet[position]  == 1) {\n      if(N<50&length(set)<=10){\n        rect(\n          xleft=position-0.2,\n          ybottom=0,\n          xright=position+0.2,\n          ytop=10,\n          col=colBarcode,\n          border=NA\n        )\n      } else{\n        abline(v=position,lwd=2,col=colBarcode)\n      }\n      if(plotNames){\n        text(\n          labels=names(reflist[position]),\n          x=position-0.2,\n          y=0,\n          srt=90,\n          offset=0,\n          pos=4,\n          font=2\n        )\n      }\n    }\n  }\n\n  ### PLOT 2: The running sum plot\n  if(!omit_middle){\n    par(mar=c(2,4.1,2,2.1))\n    plot(ind,\n         running_score,\n         sub = \"\",\n         xlab=\"\",\n         ylab=\"Enrichment Score\",\n         xlim=c(1, N),\n         ylim=c(min.plot, max.plot),\n         type = \"l\",\n         pch=20,\n         lwd = 4,\n         cex = 1,\n         col = col.f,\n         xaxs=\"r\",\n         yaxs=\"r\",\n         main=title\n    )\n    grid(col=\"dark grey\",lty=2)\n\n    # This is important: zero running score line\n    lines(c(1, N), c(0, 0), lwd = 1, lty = 1, cex = 1)\n\n    # This is also important: it's the max enrichment vertical line (aka LEADING EDGE)\n    lines(c(l.ledge.ref.plot, l.ledge.ref.plot), c(min.plot, max.plot), lwd = 1, lty = 1, cex = 1)\n\n    if(es>=0){\n      legend_position<-\"topright\"\n    }else{\n      legend_position<-\"topleft\"\n    }\n\n    # If an external NES is not provided, the standard GSEA one is shown\n    if(is.null(ext_nes)){\n      legend(legend_position,legend=c(paste(\"ES = \",signif(es,3),sep=\"\"),paste(\"NES = \",signif(nes,3),sep=\"\"),paste(\"p-value = \",signif(p.value,3),sep=\"\")),bg=\"white\")\n    } else {\n      legend(legend_position,legend=c(paste(\"NES = \",signif(ext_nes,3),sep=\"\"),paste(\"p-value = \",signif(z2p(ext_nes),3),sep=\"\")),bg=\"white\")\n    }\n  }\n\n\n  ### Plot3:  weight values\n  if(omit_middle){\n    bottomMain<-title\n  }else{\n    bottomMain<-bottomYtitle\n  }\n\n  par(mar=c(2,4.1,2,2.1))\n  plot(ind,\n       reflist,\n       type = \"l\",\n       pch=20,\n       lwd = 3,\n       xlim=c(1, N),\n       cex = 1,\n       col = 1,\n       xaxs=\"r\",\n       yaxs=\"r\",\n       main=bottomMain,\n       ylab=bottomYlabel,\n       cex.axis=0.8\n  )\n  grid(col=\"dark grey\",lty=2)\n  lines(c(1, N), c(zero.corr.line, zero.corr.line), lwd = 1, lty = 1, cex = 1, col = 1) # zero correlation horizontal line\n\n  if(omit_middle){\n    # If an external NES is not provided, the standard GSEA one is shown\n    if(is.null(ext_nes)){\n      legend(\"top\",legend=c(paste(\"ES = \",signif(es,3),sep=\"\"),paste(\"NES = \",signif(nes,3),sep=\"\"),paste(\"p-value = \",signif(p.value,3),sep=\"\")),bg=\"white\")\n    } else {\n      legend(\"top\",legend=c(paste(\"NES = \",signif(ext_nes,3),sep=\"\"),paste(\"p-value = \",signif(z2p(ext_nes),3),sep=\"\")),bg=\"white\")\n    }\n  }\n\n}\n\n\n#' Function to calculate merely the enrichment score\n#'\n#' @param reflist named vector of reference scores\n#' @param gs gene set\n#' @param w weight\n#' @return Vector of enrichment scores\n#' @export\ngsea_es <- function(reflist, gs, w = 1, sizelim = 10)\n{\n  #GSEA Gene set enrichment analysis\n  #  reflist : named vector of reference scores\n  #  gs   : gene set\n  #  w     : weight\n  #  es    : enrichment score\n  #\n  # Author: Wei Keat Lim (wl2131@columbia.edu)\n  # Modified from Matlab to R by Celine Lefebvre (lefebvre@c2b2.columbia.edu)\n  #\n\n  # combine ranked list and score\n  ix <- order(reflist, decreasing=T)\n  reflist <- reflist[ix]\n\n  es <- 0\n\n  if(!is.null(gs) && length(gs) >= sizelim)\n  {\n    # check overlap of gene sets and ranked list\n    isgs <- rep(0, length(reflist))\n    isgs[which(names(reflist) %in% gs)] <- 1\n\n    # compute ES\n    score_hit <- cumsum((abs(reflist*isgs))^w)\n    score_hit <- score_hit/tail(score_hit, 1)\n    score_miss <- cumsum(1-isgs)\n    score_miss <- score_miss/tail(score_miss, 1)\n    es_all <- score_hit - score_miss\n    #print(c(max(es_all), min(es_all)))\n    es <- max(es_all) + min(es_all)\n    #if(max(es_all) > -min(es_all)) es <- max(es_all)\n    #else es <- min(es_all)\n  }\n  return(es)\n}\n\n\n\n#' Wrapper that runs twice GSEA using two different sets\n#' E.g. positive and negative targets of a TF\n#' @param set1 The first set\n#' @param set2 The second set\n#' @param reflist The common signature, a named vector\n#' @return A GSEA2 object\n#' @export\ngsea2 <- function (reflist, set1,set2, method = c(\"permutation\", \"pareto\"),\n                   np = 1000, w = 1, gsea_null = NULL)\n{\n  #GSEA Gene set enrichment analysis of two complementary gene sets using gsea (Federico Giorgi) function\n  #  reflist : named vector of reference scores\n  #  set1   : gene set1\n  #  set2   : gene set2\n  #\n  # Author: Gonzalo Lopez\n  g1 <- gsea(reflist,set1,method=method,np = np, w = w, gsea_null = gsea_null)\n  g2 <- gsea(reflist,set2,method=method,np = np, w = w, gsea_null = gsea_null)\n  ix <- order(reflist, decreasing = T)\n  reflist <- reflist[ix]\n\n  gsea.obj <- list(\n    es1 = g1$es,es2 = g2$es,\n    nes1 = g1$nes, nes2 =  g2$nes,\n    p.value1 = g1$p.value,p.value2 =  g2$p.value,\n    ledge1 = g1$ledge,ledge2 =  g2$ledge,\n    running_score1 = g1$running_score,running_score2 =  g2$running_score,\n    set1 = set1,set2 = set2,\n    reflist = reflist,\n    inSet1 = g1$inSet,inSet2 = g2$inSet)\n  class(gsea.obj)<-\"gsea2\"\n  return(gsea.obj)\n}\n\n\n#' Plot GSEA2 results\n#'\n#' This function generates a GSEA2 plot from a gsea2 object\n#'\n#' @param gsea.obj GSEA object produced by the \\code{gsea} function\n#' @param twoColors the two colors to use for positive[1] and negative[2] enrichment scores\n#' @param colBarcode The color of the barcode\n#' @param plotNames Logical. Should the set names be plotted?\n#' @param title String to be plotted above the Running Enrichment Score\n#' @param correctEntrez Logical. Should the ids converted to gene symbols?\n#' @param bottomYlabel String for the label\n#' @param ext_nes Provide a NES from an external calculation\n#' @param omit_middle If TRUE, will not plot the running score (FALSE by default)\n#' @return Nothing, a plot is generated in the default output device\n#' @export\nplot_gsea2 <- function (gsea.obj, twoColors = c(\"red\", \"blue\"), plotNames = FALSE,\n                        title = \"Running Enrichment Score\", bottomYlabel = \"Signature values\",main=\"GSEA analysis\")\n{\n  es1 <- gsea.obj$es1; es2 <- gsea.obj$es2;\n  nes1 <- gsea.obj$nes1;nes2 <- gsea.obj$nes2;\n  p.value1 <- gsea.obj$p.value1; p.value2 <- gsea.obj$p.value2;\n  ledge1 <- gsea.obj$ledge1; ledge2 <- gsea.obj$ledge2;\n  running_score1 <- gsea.obj$running_score1;running_score2 <- gsea.obj$running_score2;\n  set1 <- gsea.obj$set1;set2 <- gsea.obj$set2;\n  inSet1 <- gsea.obj$inSet1; inSet2 <- gsea.obj$inSet2;\n  reflist <- gsea.obj$reflist\n\n  min.plot <- min(running_score1,running_score2)\n  max.plot <- max(running_score1,running_score2)\n\n  if (es1 < 0) {\n    l.ledge.ref.plot1 <- length(reflist) - length(ledge1)\n  }else {\n    l.ledge.ref.plot1 <- length(ledge1)\n  }\n\n  if (es2 < 0) {\n    l.ledge.ref.plot2 <- length(reflist) - length(ledge2)\n  }else {\n    l.ledge.ref.plot2 <- length(ledge2)\n  }\n\n  N <- length(reflist)\n  ind <- 1:N\n\n  layoutMatrix <- rbind(1, 2, 3, 4)\n  layout(layoutMatrix, heights = c(1, 5, 1, 2))\n  ##-----------------------------------------\n  par(mar = c(0, 4.1, 2, 2.1))\n  plot(0, col = \"white\", xlim = c(1, N), ylim = c(0, 10), xaxt = \"n\",\n       yaxt = \"n\", type = \"n\", frame.plot = FALSE, xlab = \"\",\n       ylab = \"\", xaxs = \"r\", yaxs = \"r\", main = paste(\"Number of elements: \",\n                                                       N, \" (in full list), \", length(set1), \" (in element set1)\",\n                                                       sep = \"\", collapse = \"\"))\n  for (position in 1:N) {\n    if (inSet1[position] == 1) {\n      if (N < 50 | length(set1) <= 10) {\n        rect(xleft = position - 0.2, ybottom = 0, xright = position +\n               0.2, ytop = 10, col = twoColors[1], border = NA)\n      }\n      else {\n        abline(v = position, lwd = 1, col = twoColors[1])\n      }\n      if (plotNames) {\n        text(labels = names(reflist[position]), x = position -\n               0.2, y = 0, srt = 90, offset = 0, pos = 4,\n             font = 2)\n      }\n    }\n  }\n  ##--------------------------------\n  par(mar = c(0, 4.1, 2, 2.1))\n  plot(x=NULL,y=NULL,xlim=range(c(1,N)), ylim=range(c(min.plot, max.plot)), sub = \"\", xlab = \"\", ylab = \"Running Enrichment Score\",\n       pch = 20, lwd = 2, cex = 1, xaxt = \"n\",\n       yaxs = \"r\", main = main)\n  grid(col = \"light grey\", lty = 2)\n  lines(ind, running_score1, sub = \"\", xlab = \"\", ylab = \"Enrichment Score\",\n        lwd = 2, cex = 1, col = twoColors[1])\n  lines(ind, running_score2, sub = \"\", xlab = \"\", ylab = \"Enrichment Score\",\n        lwd = 2, cex = 1, col = twoColors[2])\n  lines(c(1, N), c(0, 0), lwd = 1, lty = 1, cex = 1)\n  lines(c(l.ledge.ref.plot1, l.ledge.ref.plot1), c(min(running_score1),\n                                                   max(running_score1)), lwd = 1, lty = 1, cex = 1)\n  lines(c(l.ledge.ref.plot2, l.ledge.ref.plot2), c(min(running_score2),\n                                                   max(running_score2)), lwd = 1, lty = 1, cex = 1)\n  if(es1 >=0){legside1=\"topright\"\n  }else{legside1=\"topleft\"}\n  legend(legside1, legend = c(paste(\"ES1 = \", signif(es1,\n                                                     3), sep = \"\"), paste(\"NES1 = \", signif(nes1, 3), sep = \"\"),\n                              paste(\"p-value1 = \", signif(p.value1, 3), sep = \"\")),\n         bg = \"white\",box.col=twoColors[1],cex=1.5)\n  if(es2 >=0){legside2=\"bottomright\"\n  }else{legside2=\"bottomleft\"}\n  legend(legside2, legend = c(paste(\"ES2 = \", signif(es2,\n                                                     3), sep = \"\"), paste(\"NES2 = \", signif(nes2, 3), sep = \"\"),\n                              paste(\"p-value2 = \", signif(p.value2, 3), sep = \"\")),\n         bg = \"white\",box.col=twoColors[2],cex=1.5)\n\n  ##----------------------------------\n  par(mar = c(0, 4.1, 2, 2.1))\n  plot(0, col = \"white\", xlim = c(1, N), ylim = c(0, 10), xaxt = \"n\",\n       yaxt = \"n\", type = \"n\", frame.plot = FALSE, xlab = \"\",\n       ylab = \"\", xaxs = \"r\", yaxs = \"r\", main = paste(\"Number of elements: \",\n                                                       N, \" (in full list), \", length(set2), \" (in element set2)\",\n                                                       sep = \"\", collapse = \"\"))\n  for (position in 1:N) {\n    if (inSet2[position] == 1) {\n      if (N < 50 | length(set2) <= 10) {\n        rect(xleft = position - 0.2, ybottom = 0, xright = position +\n               0.2, ytop = 10, col = twoColors[2], border = NA)\n      }\n      else {\n        abline(v = position, lwd = 1, col = twoColors[2])\n      }\n      if (plotNames) {\n        text(labels = names(reflist[position]), x = position -\n               0.2, y = 0, srt = 90, offset = 0, pos = 4,\n             font = 2)\n      }\n    }\n  }\n  #-----------------------------------\n  par(mar = c(2, 4.1, 2, 2.1))\n  plot(x=NULL,y=NULL,xlim=range(c(0,N)),ylim=range(c(min(reflist),max(reflist))), type = \"b\", lwd = 2,\n       cex = 1, col = 1, xaxs = \"r\", yaxs = \"r\", main = NULL, ylab = bottomYlabel)\n  grid(col = \"light grey\", lty = 2)\n  abline(h=0, lwd = 1,lty = 1, cex = 1, col = 1)\n  lines(ind,reflist,lty=1,lwd=2)\n  legend(\"top\", c(\"Reference list\"),bty='n',cex=1.4)\n}\n\n#' Plot GSEA results as a leading edge plot\n#'\n#' This function generates a leading edge plot from a gsea object\n#'\n#' @param gsea.obj GSEA object produced by the \\code{gsea} function\n#' @param numcol Number of columns in the output plot\n#' @param let.size Numeric, pointsize of the gene names\n#' @param annot NULL by default/ An annaotation vector of name conversion, e.g. you can translate entrez to symbols\n#' @return Nothing, a plot is generated in the default output device\n#' @export\nledge_plot <- function(gobj,numcol=6,let.size=2.5,annot=NULL){\n\n  library(reshape2) ## melt\n  library(plyr)     ## round_any\n  library(ggplot2)\n\n  rounded <- ceiling((length(gobj$set)+2)/numcol)*numcol\n  numrow <- rounded/numcol\n  numna <- rounded-(length(gobj$set)+2)\n\n  leset <- intersect(gobj$ledge,gobj$set)\n  poset <- names(which(gobj$reflist[gobj$set] >= 0))\n  neset <- names(which(gobj$reflist[gobj$set] < 0))\n\n  if(gobj$es > 0 ){\n    s1 <- c(quantile(gobj$reflist,0.99),sort(gobj$reflist[leset],decreasing=TRUE))\n    s2 <- sort(gobj$reflist[setdiff(poset,leset)],decreasing=TRUE)\n    s3 <- c(sort(gobj$reflist[neset],decreasing=TRUE),quantile(gobj$reflist,0.01))\n    colv <- c(rep(\"black\",length(s1)),rep(\"grey\",length(s2)),rep(\"grey\",numna),rep(\"grey\",length(s3)))\n  }else if(gobj$es < 0){\n    s1 <- c(quantile(gobj$reflist,0.01),sort(gobj$reflist[leset]))\n    s2 <- sort(gobj$reflist[setdiff(neset,leset)])\n    s3 <- c(sort(gobj$reflist[poset]),quantile(gobj$reflist,0.99))\n    colv <- c(rep(\"black\",length(s1)),rep(\"grey\",length(s2)),rep(\"grey\",numna),rep(\"grey\",length(s3)))\n  }\n  dat <- expand.grid(var1=1:numcol, var2=numrow:1)\n  dat$value <- c(s1,s2,rep(0,numna),s3)\n  if(is.null(annot)){ dat$labels <- c(names(s1),names(s2),rep(\"\",numna),names(s3))\n  }else{\n    dat$labels <- paste(c(annot[names(s1)],annot[names(s2)],rep(\"\",numna),annot[names(s3)]),c(names(s1),names(s2),rep(\"\",numna),names(s3)),sep=\"\\n\")  }\n\n  dat$color <- colv\n  dat$colorScale  <- val2col(dat$value)\n\n  ggplot(dat, aes(x=var1,y=var2,label=labels),main=\"\",colour='white')+\n    geom_tile(aes(fill = value),colour=colv) +\n    scale_fill_gradient2(low=\"blue\",mid=\"white\", high=\"red\") +\n    geom_text(size=let.size)\n\n}\n\n\n#' Probability density of Pareto distributions\n#'\n#' Gives NA on values below the threshold\n#'\n#' @param x Data vector of log probability densities\n#' @return Vector of (log) probability densities\n#' @export\ndpareto <- function(x, threshold = 1, exponent, log=FALSE) {\n  # Avoid doing limited-precision arithmetic followed by logs if we want\n  # the log!\n  if (!log) {\n    prefactor <- (exponent-1)/threshold\n    f <- function(x) {prefactor*(x/threshold)^(-exponent)}\n  } else {\n    prefactor.log <- log(exponent-1) - log(threshold)\n    f <- function(x) {prefactor.log -exponent*(log(x) - log(threshold))}\n  }\n  d <- ifelse(x<threshold,NA,f(x))\n  return(d)\n}\n\n#' Cumulative distribution function of the Pareto distributions\n#' '\n#' Gives NA on values < threshold\n#' @param x Data vector, lower threshold, scaling exponent, usual flags\n#' @return Vector of (log) probabilities\n#' @export\nppareto <- function(x, threshold=1, exponent, lower.tail=TRUE) {\n  if (!lower.tail) {\n    f <- function(x) {(x/threshold)^(1-exponent)}\n  }\n  if (lower.tail) {\n    f <- function(x) { 1 - (x/threshold)^(1-exponent)}\n  }\n  p <- ifelse(x < threshold, NA, f(x))\n  return(p)\n}\n\n#' Estimate parameters of Pareto distribution\n#'\n#' A wrapper for functions implementing actual methods\n#' @param data data vector, lower threshold (or \"find\", indicating it should be found from the data), method (likelihood or regression, defaulting to former)\n#' @return List indicating type of distribution (\"pareto\"), parameters, information about fit (depending on method), OR a warning and NA if method is not recognized\n#' @export\npareto.fit <- function(data, threshold) {\n  return(pareto.fit.ml(data,threshold))\n}\n\n#' Estimate scaling exponent of Pareto distribution by maximum likelihood\n#' @param data Data vector, lower threshold\n#' @return List giving distribution type (\"pareto\"), parameters, log-likelihood\n#' @export\npareto.fit.ml <- function (data, threshold) {\n  data <- data[data>=threshold]\n  n <- length(data)\n  x <- data/threshold\n  alpha <- 1 + n/sum(log(x))\n  loglike = pareto.loglike(data,threshold,alpha)\n  ks.dist <- ks.dist.fixed.pareto(data,threshold=threshold,exponent=alpha)\n  fit <- list(type=\"pareto\", exponent=alpha, xmin=threshold, loglike = loglike,\n              ks.dist = ks.dist, samples.over.threshold=n)\n  return(fit)\n}\n\n#' Calculate log-likelihood under a Pareto distribution\n#' @param x Data vector, lower threshold, scaling exponent\n#' @return Real-valued log-likelihood\n#' @export\npareto.loglike <- function(x, threshold, exponent) {\n  L <- sum(dpareto(x, threshold = threshold, exponent = exponent, log = TRUE))\n  return(L)\n}\n\n#' Calculate KS distanced between a data set and given Pareto distribution\n#' Not intended for users\n#' @param data Data vector\n#' @param threshold real threshold\n#' @param exponent real exponent\n#' @return real-valued KS statistic\n#' @export\nks.dist.fixed.pareto <- function(data,threshold,exponent) {\n  data <- data[data>=threshold]\n  d <- suppressWarnings(ks.test(data,ppareto,threshold=threshold,exponent=exponent))\n  # ks.test complains about p-values when there are ties, we don't care\n  return(as.vector(d$statistic))\n}\n\n\n\n",
    "created" : 1491675957108.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2219560982",
    "id" : "CFD4FB63",
    "lastKnownWriteTime" : 1495126938,
    "last_content_update" : 1495126938,
    "path" : "D:/Dropbox/rstudio/vulcanpackage/vulcan/R/gsea.R",
    "project_path" : "R/gsea.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}