{
    "collab_server" : "",
    "contents" : "#' Function to import BAM files\n#'\n#' This function coalesces and annotates a set of BAM files into peak-centered data\n#'\n#' @param sheetfile path to a csv annotation file containing sample information and BAM location\n#' @param intervals size of the peaks. If NULL (default) it is inferred from the average fragment length observed in the dataset\n#'\n#' @return a list\n#'\n#' @examples\n#' vulcan.import()\n#'\n#' @export\nvulcan.import<-function(sheetfile,intervals=NULL){\n  # Check the dataset\n  sheet<-read.csv(sheetfile,as.is=TRUE)\n\n  # Generate a DiffBind object\n  dbobj<-dba(sampleSheet=sheetfile)\n  message(\"Sheet loaded. You have \",nrow(sheet), \" samples and \",length(unique(sheet$Condition)),\" conditions\")\n\n  # Select the interval size automatically (if not provided by the user)\n  if(is.null(intervals)){\n    # List of bam files\n    bam.files <- sheet[,\"bamReads\"]\n    intervals<-average_fragment_length(bam.files,plot=FALSE)*2\n    message(\"Peak size automatically detected as \",intervals,\"nt\")\n  }\n\n  # Count reads in binding sites intervals\n  dbcounts<-dba.count(dbobj,summits=intervals)\n\n  # Extract counts from the dbacount object\n  listcounts<-dbcounts$peaks\n  names(listcounts)<-dbcounts$samples[,1]\n\n  # Prepare RPKM matrix\n  first<-listcounts[[1]]\n  rawmat<-matrix(NA, nrow = nrow(first), ncol = length(listcounts)+3)\n  colnames(rawmat)<-c(\"Chr\",\"Start\",\"End\",names(listcounts))\n  rownames(rawmat)<-1:nrow(rawmat)\n  rawmat<-as.data.frame(rawmat)\n  rawmat[,1]<-as.character(first[,1])\n  rawmat[,2]<-as.integer(first[,2])\n  rawmat[,3]<-as.integer(first[,3])\n  for(i in 1:length(listcounts)){\n    rawmat[,names(listcounts)[i]]<-as.numeric(listcounts[[i]]$RPKM)\n  }\n  peakrpkms<-rawmat\n  rm(rawmat)\n\n  # Prepare Count matrix\n  first<-listcounts[[1]]\n  rawmat<-matrix(NA, nrow = nrow(first), ncol = length(listcounts)+3)\n  colnames(rawmat)<-c(\"Chr\",\"Start\",\"End\",names(listcounts))\n  rownames(rawmat)<-1:nrow(rawmat)\n  rawmat<-as.data.frame(rawmat)\n  rawmat[,1]<-as.character(first[,1])\n  rawmat[,2]<-as.integer(first[,2])\n  rawmat[,3]<-as.integer(first[,3])\n  for(i in 1:length(listcounts)){\n    rawmat[,names(listcounts)[i]]<-as.integer(listcounts[[i]]$Reads)\n  }\n  peakcounts<-rawmat\n  rm(rawmat)\n\n\n  # Create an annotation structure\n  samples<-list()\n  conditions<-unique(sheet$Condition)\n  for(cond in conditions){\n    heresamples<-sheet$SampleID[sheet$Condition==cond]\n    samples[[cond]]<-heresamples\n  }\n\n  # Return output\n  vobj<-list(peakcounts=peakcounts,samples=samples,peakrpkms=peakrpkms)\n  return(vobj)\n}\n\nvulcan.annotate<-function(vobj,lborder=-10000,rborder=10000,\n                          method=c(\"closest\",\"strongest\",\"sum\",\"topvar\",\"farthest\",\"lowvar\")\n){\n  # Annotate (hg19)\n  annotation<-toGRanges(TxDb.Hsapiens.UCSC.hg19.knownGene, feature=\"gene\")\n\n  ##### PROCESS RAW COUNTS\n  gr<-GRanges(vobj$peakcounts)\n  anno<-annotatePeakInBatch(gr,AnnotationData=annotation,output=\"overlapping\",FeatureLocForDistance=\"TSS\",bindingRegion=c(lborder,rborder))\n\n  # Convert to a more handy data frame\n  dfanno<-anno\n  names(dfanno)<-1:length(dfanno)\n  dfanno<-as.data.frame(dfanno)\n\n  # Prepare the output table\n  allsamples<-unique(unlist(vobj$samples))\n  genes<-unique(dfanno$feature)\n  peakspergene<-table(dfanno$feature)\n  rawcounts<-matrix(NA,nrow=length(genes),ncol=length(allsamples))\n  colnames(rawcounts)<-allsamples\n  rownames(rawcounts)<-genes\n\n  # All methods: if a gene has a single peak, you select that\n  for(i in 1:length(genes)){\n    gene<-genes[i]\n    if(peakspergene[gene]==1){\n      rawcounts[gene,allsamples]<-as.numeric(dfanno[dfanno$feature==gene,allsamples])\n    }\n  }\n\n  # Method closest: when multiple peaks are found, keep only the closest to the TSS as the representative one\n  if(method==\"closest\"){\n    for(i in 1:length(genes)){\n      gene<-genes[i]\n      if(peakspergene[gene]>1){\n        subanno<-dfanno[dfanno$feature==gene,]\n        closest<-which.min(subanno$distanceToStart)\n        # if(any(subanno$distanceToStart<0)){\n        #   stop(\"Stop! Negative distances are not allowed\")\n        # }\n        rawcounts[gene,allsamples]<-as.numeric(subanno[closest,allsamples])\n      }\n    }\n  }\n\n  # Method farthest: when multiple peaks are found, keep only the closest to the TSS as the representative one\n  if(method==\"farthest\"){\n    for(i in 1:length(genes)){\n      gene<-genes[i]\n      if(peakspergene[gene]>1){\n        subanno<-dfanno[dfanno$feature==gene,]\n        farthest<-which.max(subanno$distanceToStart)\n        rawcounts[gene,allsamples]<-as.numeric(subanno[farthest,allsamples])\n      }\n    }\n  }\n\n\n  # Method sum: when multiple peaks are found, keep the strongest as the representative one\n  if(method==\"sum\"){\n    for(i in 1:length(genes)){\n      gene<-genes[i]\n      if(peakspergene[gene]>1){\n        subanno<-dfanno[dfanno$feature==gene,]\n        sums<-apply(subanno[,allsamples],2,sum)\n        rawcounts[gene,allsamples]<-as.numeric(sums)\n      }\n    }\n  }\n\n  # Method strongest: when multiple peaks are found, keep the strongest as the representative one\n  if(method==\"strongest\"){\n    for(i in 1:length(genes)){\n      gene<-genes[i]\n      if(peakspergene[gene]>1){\n        subanno<-dfanno[dfanno$feature==gene,]\n        sums<-apply(subanno[,allsamples],1,sum)\n        top<-which.max(sums)\n        rawcounts[gene,allsamples]<-as.numeric(subanno[top,allsamples])\n      }\n    }\n  }\n\n  # Method topvar: when multiple peaks are found, keep the most varying as the representative one\n  if(method==\"topvar\"){\n    for(i in 1:length(genes)){\n      gene<-genes[i]\n      if(peakspergene[gene]>1){\n        subanno<-dfanno[dfanno$feature==gene,]\n        vars<-apply(subanno[,allsamples],1,var)\n        top<-which.max(vars)\n        rawcounts[gene,allsamples]<-as.numeric(subanno[top,allsamples])\n      }\n    }\n  }\n\n  # Method lowvar: when multiple peaks are found, keep the least varying as the representative one\n  if(method==\"lowvar\"){\n    for(i in 1:length(genes)){\n      gene<-genes[i]\n      if(peakspergene[gene]>1){\n        subanno<-dfanno[dfanno$feature==gene,]\n        vars<-apply(subanno[,allsamples],1,var)\n        top<-which.min(vars)\n        rawcounts[gene,allsamples]<-as.numeric(subanno[top,allsamples])\n      }\n    }\n  }\n\n  ##### PROCESS RPKMS\n  gr<-GRanges(vobj$peakrpkms)\n  anno<-annotatePeakInBatch(gr,AnnotationData=annotation,output=\"overlapping\",FeatureLocForDistance=\"TSS\",bindingRegion=c(lborder,rborder))\n\n  # Convert to a more handy data frame\n  dfanno<-anno\n  names(dfanno)<-1:length(dfanno)\n  dfanno<-as.data.frame(dfanno)\n\n  # Prepare the output table\n  allsamples<-unique(unlist(vobj$samples))\n  genes<-unique(dfanno$feature)\n  peakspergene<-table(dfanno$feature)\n  rpkms<-matrix(NA,nrow=length(genes),ncol=length(allsamples))\n  colnames(rpkms)<-allsamples\n  rownames(rpkms)<-genes\n\n  # All methods: if a gene has a single peak, you select that\n  for(i in 1:length(genes)){\n    gene<-genes[i]\n    if(peakspergene[gene]==1){\n      rpkms[gene,allsamples]<-as.numeric(dfanno[dfanno$feature==gene,allsamples])\n    }\n  }\n\n  # Method closest: when multiple peaks are found, keep only the closest to the TSS as the representative one\n  if(method==\"closest\"){\n    for(i in 1:length(genes)){\n      gene<-genes[i]\n      if(peakspergene[gene]>1){\n        subanno<-dfanno[dfanno$feature==gene,]\n        closest<-which.min(subanno$distanceToStart)\n        # if(any(subanno$distanceToStart<0)){\n        #   stop(\"Stop! Negative distances are not allowed\")\n        # }\n        rpkms[gene,allsamples]<-as.numeric(subanno[closest,allsamples])\n      }\n    }\n  }\n\n  # Method farthest: when multiple peaks are found, keep only the closest to the TSS as the representative one\n  if(method==\"farthest\"){\n    for(i in 1:length(genes)){\n      gene<-genes[i]\n      if(peakspergene[gene]>1){\n        subanno<-dfanno[dfanno$feature==gene,]\n        farthest<-which.max(subanno$distanceToStart)\n        rpkms[gene,allsamples]<-as.numeric(subanno[farthest,allsamples])\n      }\n    }\n  }\n\n\n  # Method sum: when multiple peaks are found, keep the strongest as the representative one\n  if(method==\"sum\"){\n    for(i in 1:length(genes)){\n      gene<-genes[i]\n      if(peakspergene[gene]>1){\n        subanno<-dfanno[dfanno$feature==gene,]\n        sums<-apply(subanno[,allsamples],2,sum)\n        rpkms[gene,allsamples]<-as.numeric(sums)\n      }\n    }\n  }\n\n  # Method strongest: when multiple peaks are found, keep the strongest as the representative one\n  if(method==\"strongest\"){\n    for(i in 1:length(genes)){\n      gene<-genes[i]\n      if(peakspergene[gene]>1){\n        subanno<-dfanno[dfanno$feature==gene,]\n        sums<-apply(subanno[,allsamples],1,sum)\n        top<-which.max(sums)\n        rpkms[gene,allsamples]<-as.numeric(subanno[top,allsamples])\n      }\n    }\n  }\n\n  # Method topvar: when multiple peaks are found, keep the most varying as the representative one\n  if(method==\"topvar\"){\n    for(i in 1:length(genes)){\n      gene<-genes[i]\n      if(peakspergene[gene]>1){\n        subanno<-dfanno[dfanno$feature==gene,]\n        vars<-apply(subanno[,allsamples],1,var)\n        top<-which.max(vars)\n        rpkms[gene,allsamples]<-as.numeric(subanno[top,allsamples])\n      }\n    }\n  }\n\n  # Method lowvar: when multiple peaks are found, keep the least varying as the representative one\n  if(method==\"lowvar\"){\n    for(i in 1:length(genes)){\n      gene<-genes[i]\n      if(peakspergene[gene]>1){\n        subanno<-dfanno[dfanno$feature==gene,]\n        vars<-apply(subanno[,allsamples],1,var)\n        top<-which.min(vars)\n        rpkms[gene,allsamples]<-as.numeric(subanno[top,allsamples])\n      }\n    }\n  }\n\n  ### Fix data types as needed\n  for(j in 1:ncol(rawcounts)){\n    rawcounts[,j]<-as.numeric(rawcounts[,j])\n  }\n  rawcounts<-as.matrix(rawcounts)\n\n  for(j in 1:ncol(rpkms)){\n    rpkms[,j]<-as.numeric(rpkms[,j])\n  }\n  rpkms<-as.matrix(rpkms)\n\n  # Return object\n  vobj$rawcounts<-rawcounts\n  vobj$rpkms<-rpkms\n  return(vobj)\n}\n\n\n\n# vulcan.signature<-function(vobj,contrast=1){\n#   anno<-vobj[[contrast]]\n#   ## As signature we use -log10(sign(fold)*p)\n#   # Fold change is not recapitulating the replicate agreements\n#   signature<-anno$p.value*sign(anno$Fold)\n#   names(signature)<-anno$feature\n#   # Uniform ultrasmall gaussian noise (if by chance no reflist genes get into the null GSEA function, we get a division by zero)\n#   set.seed(1)\n#   othergenes<-setdiff(allgenes,names(signature))\n#   gaussiannoise<-setNames(rnorm(length(othergenes),mean=0,sd=0.01),othergenes) # very small\n#   signature<-c(signature,gaussiannoise)\n# }\n\n\n\n#' Function to normalize promoter peak data\n#'\n#' This function normalizes gene-centered ChIP-Seq data using VST\n#'\n#' @param vobj a list, the output of the \\code{\"vulcan.annotate\"} function\n#'\n#' @return a list\n#'\n#' @examples\n#' vulcan.normalize()\n#'\n#' @export\nvulcan.normalize<-function(vobj){\n  # Extract raw counts from object\n  samples<-vobj$samples\n  rawcounts<-vobj$rawcounts\n  allsamples<-unique(unlist(samples))\n  allgenes<-rownames(rawcounts)\n\n  # Generate a normalized abundance object\n  conditions<-c()\n  for(i in 1:length(samples)){\n    conditions<-c(conditions,rep(names(samples)[i],length(samples[[i]])))\n  }\n  conditions<-factor(conditions)\n  cds<-newCountDataSet(vobj$rawcounts,conditions)\n  cds<-estimateSizeFactors(cds)\n  cds<-estimateDispersions(cds,fitType=\"local\")\n  vsd<-varianceStabilizingTransformation(cds)\n  normalized<-exprs(vsd)\n  rownames(normalized)<-rownames(rawcounts)\n  vobj$normalized<-normalized\n  return(vobj)\n}\n\n#' VULCAN - VirtUaL Chipseq data Analysis using Networks\n#'\n#' This function calculates the enrichment of a gene regulatory network over a ChIP-Seq derived signature\n#'\n#' @param vobj a list, the output of the \\code{\"vulcan.normalize\"} function\n#' @param network an object of class \\code{\"viper::regulon\"}\n#' @param contrast a vector of two fields, containing the condition names to be compared (1 vs 2)\n#' @param annotation an optional named vector to convert gene identifiers (e.g. entrez ids to gene symbols)\n#' Default (NULL) won't convert gene names.\n#'\n#' @return a list\n#'\n#' @examples\n#' vulcan.normalize()\n#'\n#' @export\nvulcan<-function(vobj,network,contrast,annotation=NULL){\n  tfs<-names(network)\n  samples<-vobj$samples\n  normalized<-vobj$normalized\n\n  # Prepare output objects\n  msvipers<-matrix(NA,ncol=3,nrow=length(tfs))\n  rownames(msvipers)<-tfs\n  # Define contrast\n  a<-samples[[contrast[1]]]\n  b<-samples[[contrast[2]]]\n  # Vulcan msviper implementation\n  set.seed(1)\n  signature<-rowTtest(normalized[,a],normalized[,b])$statistic\n  dnull<-ttestNull(normalized[,a],normalized[,b],per=1000)\n  msviper<-msviper(signature,network,dnull,minsize=10)\n  # Annotate\n  if(!is.null(annotation)){\n    msviper<-msviperAnnot(msviper,annotation)\n  }\n  vobj$msviper<-msviper\n  # Specific Master Regulators\n  mrs<-cbind(msviper$es$nes,z2p(msviper$es$nes))\n  colnames(mrs)<-c(\"NES\",\"pvalue\")\n  vobj$mrs<-mrs\n\n  return(vobj)\n}\n\n\nvulcan.pathways<-function(vobj,pathways,contrast=NULL,method=c(\"GSEA\",\"REA\")){\n  normalized<-vobj$normalized\n  samples<-vobj$samples\n  allgenes<-unique(unlist(pathways))\n\n  # Specific contrast\n  if(!setequal(contrast,\"all\")){\n    # Define contrast\n    a<-samples[[contrast[1]]]\n    b<-samples[[contrast[2]]]\n\n    # Prepare signature\n    set.seed(1)\n    signature<-rowTtest(normalized[,a],normalized[,b])$statistic\n    othergenes<-setdiff(allgenes,names(signature))\n    gaussiannoise<-setNames(rnorm(length(othergenes),mean=0,sd=0.01),othergenes) # very small\n    signature<-c(signature,gaussiannoise)\n\n    # GSEA\n    if(method==\"GSEA\"){\n      gsea.pathways<-setNames(rep(0,length(pathways)),names(pathways))\n      message(\"Running GSEA for \",length(pathways),\" pathways\")\n      pb<-txtProgressBar(0,length(pathways),style=3)\n      i<-0\n      for(pname in names(pathways)){\n        p<-pathways[[pname]]\n        obj<-gsea(reflist=signature,set=p,method=\"pareto\",np=100)\n        gsea.pathways[pname]<-obj$nes\n        setTxtProgressBar(pb,i<-i+1)\n      }\n      return(gsea.pathways)\n    }\n\n    # REA\n    if(method==\"REA\"){\n      rea.pathways<-setNames(rep(0,length(pathways)),names(pathways))\n      message(\"Running REA for \",length(pathways),\" pathways\")\n      rea.pathways<-rea(signatures=signature,groups=pathways,minsize=1)\n      return(rea.pathways)\n    }\n  } else {\n    if(method!=\"REA\"){\n      stop(\"Multiple signatures supported only with method='REA'\")\n    }\n    signatures<-t(scale(t(vobj$normalized)))\n    rea.pathways<-rea(signatures=signatures,groups=pathways,minsize=1)\n    return(rea.pathways)\n  }\n\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n",
    "created" : 1491434617707.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2537787668",
    "id" : "6F5F4D7F",
    "lastKnownWriteTime" : 1495122058,
    "last_content_update" : 1495122058,
    "path" : "D:/Dropbox/rstudio/vulcanpackage/vulcan/R/vulcan.R",
    "project_path" : "R/vulcan.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}